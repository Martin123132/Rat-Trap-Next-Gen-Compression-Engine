import argparse
import os
import io
import tarfile
import struct
import json
import time
import threading
import zlib
import hashlib # Import hashlib for SHA256
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple, Optional, Iterable, Dict
from concurrent.futures import ThreadPoolExecutor, as_completed

try:
    import zstandard as zstd  # optional
    HAS_ZSTD = True
except Exception:
    zstd = None
    HAS_ZSTD = False

try:
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM  # optional
    HAS_AESGCM = True
except Exception:
    AESGCM = None
    HAS_AESGCM = False

try:
    import xxhash
    HAS_XX = True
except Exception:
    xxhash = None
    HAS_XX = False

# -----------------------------------------------------------------------------
# Morton encoding helpers for voxel keys

_DILATE16 = [0] * 65536

def _init_dilate():
    for i in range(65536):
        n = i
        n = (n | (n << 16)) & 0x0000FFFF0000FFFF
        n = (n | (n << 8)) & 0x00FF00FF00FF00FF
        n = (n | (n << 4)) & 0x0F0F0F0F0F0F0F0F
        n = (n | (n << 2)) & 0x3333333333333333
        n = (n | (n << 1)) & 0x5555555555555555
        _DILATE16[i] = n

_init_dilate()

def morton64(x: int, y: int, z: int) -> int:
    x &= 0x1FFFFF
    y &= 0x1FFFFF
    z &= 0x1FFFFF
    xx = _DILATE16[x & 0xFFFF] | (_DILATE16[(x >> 16) & 0xFFFF] << 32)
    yy = _DILATE16[y & 0xFFFF] | (_DILATE16[(y >> 16) & 0xFFFF] << 32)
    zz = _DILATE16[z & 0xFFFF] | (_DILATE16[(z >> 16) & 0xFFFF] << 32)
    return (xx | (yy << 1) | (zz << 2)) & ((1 << 64) - 1)

def inv_morton64(k: int) -> Tuple[int, int, int]:
    def compact(n: int) -> int:
        n &= 0x5555555555555555
        n = (n | (n >> 1)) & 0x3333333333333333
        n = (n | (n >> 2)) & 0x0F0F0F0F0F0F0F0F
        n = (n | (n >> 4)) & 0x00FF00FF00FF00FF
        n = (n | (n >> 8)) & 0x0000FFFF0000FFFF
        n = (n | (n >> 16)) & 0x00000000FFFFFFFF
        return n
    x = compact(k) & 0x1FFFFF
    y = compact(k >> 1) & 0x1FFFFF
    z = compact(k >> 2) & 0x1FFFFF
    return x, y, z

# Varint helpers

def enc_varint(n: int) -> bytes:
    out = bytearray()
    while True:
        b = n & 0x7F
        n >>= 7
        if n:
            out.append(0x80 | b)
        else:
            out.append(b)
            break
    return bytes(out)

def dec_varint(buf: bytes, off: int) -> Tuple[int, int]:
    shift = 0
    val = 0
    while True:
        b = buf[off]
        off += 1
        val |= (b & 0x7F) << shift
        if not (b & 0x80):
            break
        shift += 7
    return val, off

# Bloom filter hash (deterministic)

def _bloom_hash(key: int, i: int) -> int:
    x = (key + 0x9E3779B97F4A7C15 + i) & 0xFFFFFFFFFFFFFFFF
    x = (x ^ (x >> 30)) * 0xBF58476D1CE4E5B9 & 0xFFFFFFFFFFFFFFFF
    x = (x ^ (x >> 27)) * 0x94D049BB133111EB & 0xFFFFFFFFFFFFFFFF
    x = x ^ (x >> 31)
    return x & 0xFFFFFFFF

def _bloom_add(bits: bytearray, key: int, m: int, h: int = 3) -> None:
    for i in range(h):
        hv = _bloom_hash(key, i) % m
        bits[hv // 8] |= 1 << (hv % 8)

def _bloom_maybe(bits: bytes, key: int, m: int, h: int = 3) -> bool:
    for i in range(h):
        hv = _bloom_hash(key, i) % m
        if not (bits[hv // 8] & (1 << (hv % 8))):
            return False
    return True

# Format constants

MAGIC = b"MBT2\0"
VERSION = 2

FLAG_ZLIB = 1 << 0
FLAG_ZSTD = 1 << 1
FLAG_AESGCM = 1 << 2
FLAG_VARINT = 1 << 3
FLAG_COLUMN = 1 << 4
FLAG_HILBERT = 1 << 5
FLAG_KEY_128 = 1 << 6

HEADER = struct.Struct("<5sB I H I Q")
ENTRY = struct.Struct("<Q I Q I Q 32s H I")
FOOTER = struct.Struct("<I 32s 32s I")

@dataclass
class WriterCfg:
    """Recommended configuration for writing MBT2 archives."""
    target_bucket_kb: int = 128
    use_zstd: bool = True
    zstd_level: int = 3
    threads: int = max(1, os.cpu_count() or 1)
    aesgcm_key: Optional[bytes] = None
    sha256_each: bool = False
    bloom_bits: int = 2048
    column_layout: bool = True

def _compress(raw: bytes, zstd_on: bool, lvl: int = 3) -> bytes:
    if zstd_on and HAS_ZSTD:
        return zstd.ZstdCompressor(level=lvl).compress(raw)
    return zlib.compress(raw, 6)

def _decompress(comp: bytes) -> bytes:
    if HAS_ZSTD and len(comp) >= 4 and comp[:4] == b"\x28\xB5\x2F\xFD":
        return zstd.ZstdDecompressor().decompress(comp)
    return zlib.decompress(comp)

def _maybe_encrypt(aes_key: Optional[bytes], data: bytes, aad: bytes) -> bytes:
    if not aes_key or not HAS_AESGCM:
        return data
    nonce = os.urandom(12)
    return nonce + AESGCM(aes_key).encrypt(nonce, data, aad)

def _maybe_decrypt(aes_key: Optional[bytes], data: bytes, aad: bytes) -> bytes:
    if not aes_key or not HAS_AESGCM:
        return data
    nonce, ct = data[:12], data[12:]
    return AESGCM(aes_key).decrypt(nonce, ct, aad)

def _xx64(b: bytes) -> int:
    if HAS_XX:
        return xxhash.xxh64(b).intdigest()
    return int.from_bytes(hashlib.blake2b(b, digest_size=8).digest(), "little")

def _autotune_bucket_kb(n: int, approx_rec_bytes: int = 20) -> int:
    recs = max(4096, min(12288, n // 80))
    kb = max(64, min(256, (recs * approx_rec_bytes) // 1024))
    return int(kb)

def _pack_bucket(keys: List[int], masses: List[float], ents: List[float], taus: List[float], column: bool = True) -> bytes:
    n = len(keys)
    if n == 0:
        return b""
    out = bytearray()
    out += struct.pack("<Q", keys[0])
    prev = keys[0]
    for i in range(1, n):
        d = keys[i] - prev
        out += enc_varint(d)
        prev = keys[i]
    if column:
        out += struct.pack(f"<{n}f", *masses)
        out += struct.pack(f"<{n}f", *ents)
        out += struct.pack(f"<{n}f", *taus)
    else:
        for i in range(n):
            out += struct.pack("<fff", masses[i], ents[i], taus[i])
    return bytes(out)

def _build_buckets(sorted_recs: List[Tuple[int, float, float, float]], target_kb: int) -> List[Tuple[List[int], List[float], List[float], List[float]]]:
    target = target_kb * 1024
    out = []
    ks: List[int] = []
    ms: List[float] = []
    es: List[float] = []
    ts: List[float] = []
    size = 0
    for k, m, e, t in sorted_recs:
        add = (3 if ks else 8) + 12
        if size + add > target and ks:
            out.append((ks, ms, es, ts))
            ks, ms, es, ts = [], [], [], []
            size = 0
        ks.append(k)
        ms.append(m)
        es.append(e)
        ts.append(t)
        size += add
    if ks:
        out.append((ks, ms, es, ts))
    return out

def write_mbt2(path: Path, records: List[Tuple[int, float, float, float]], cfg: WriterCfg = WriterCfg()) -> Dict:
    path = Path(path)
    t_sort0 = time.perf_counter()
    records.sort(key=lambda r: r[0])
    t_sort = time.perf_counter() - t_sort0
    if cfg.target_bucket_kb <= 0:
        cfg.target_bucket_kb = _autotune_bucket_kb(len(records))
    buckets = _build_buckets(records, cfg.target_bucket_kb)
    nb = len(buckets)
    flags = 0
    flags |= FLAG_ZSTD if (cfg.use_zstd and HAS_ZSTD) else FLAG_ZLIB
    flags |= FLAG_VARINT
    if cfg.column_layout:
        flags |= FLAG_COLUMN
    if cfg.aesgcm_key and HAS_AESGCM:
        flags |= FLAG_AESGCM
    with open(path, "w+b") as f:
        f.write(HEADER.pack(MAGIC, VERSION, flags, cfg.target_bucket_kb, nb, 0))
        header_end = f.tell()
        bloom_bytes = cfg.bloom_bits // 8
        entry_size = ENTRY.size + bloom_bytes
        table_ofs = header_end
        f.seek(table_ofs + nb * entry_size)
        metas = []
        lock = threading.Lock()
        def write_bucket(i: int, b) -> None:
            ks, ms, es, ts = b
            raw = _pack_bucket(ks, ms, es, ts, column=bool(flags & FLAG_COLUMN))
            comp = _compress(raw, zstd_on=bool(flags & FLAG_ZSTD), lvl=cfg.zstd_level)
            comp = _maybe_encrypt(cfg.aesgcm_key if (flags & FLAG_AESGCM) else None, comp, aad=struct.pack("<I", i))
            xx = _xx64(comp)
            sh = hashlib.sha256(comp).digest() if cfg.sha256_each else b"\x00" * 32
            bloom = bytearray(bloom_bytes)
            for kk in ks:
                _bloom_add(bloom, kk, cfg.bloom_bits)
            with lock:
                pos = f.tell()
                f.write(comp)
                metas.append((ks[0], len(ks), pos, len(comp), xx, sh, bytes(bloom)))
        t_comp0 = time.perf_counter()
        with ThreadPoolExecutor(max_workers=cfg.threads) as ex:
            futs = [ex.submit(write_bucket, i, b) for i, b in enumerate(buckets)]
            for fu in as_completed(futs):
                fu.result()
        t_comp = time.perf_counter() - t_comp0
        metas.sort(key=lambda m: m[0])
        data_end = f.tell()
        f.seek(table_ofs)
        for (start, count, off, length, xx, sh, bloom) in metas:
            f.write(ENTRY.pack(start, count, off, length, xx, sh, len(bloom), 0))
            f.write(bloom)
        f.seek(table_ofs)
        table_blob = f.read(nb * entry_size)
        table_hash = hashlib.sha256(table_blob).digest()
        leaves = [sh if cfg.sha256_each else xx.to_bytes(8, "little") for (_, _, _, _, xx, sh, _) in metas]
        if leaves:
            cur = [hashlib.sha256(x).digest() if len(x) != 32 else x for x in leaves]
            while len(cur) > 1:
                nxt = []
                for i in range(0, len(cur), 2):
                    a = cur[i]
                    b = cur[i + 1] if i + 1 < len(cur) else a
                    nxt.append(hashlib.sha256(a + b).digest())
                cur = nxt
            merkle = cur[0]
        else:
            merkle = b"\x00" * 32
        f.seek(data_end)
        feature_crc = zlib.crc32(struct.pack("<IHH", VERSION, cfg.target_bucket_kb, flags)) & 0xFFFFFFFF
        f.write(FOOTER.pack(nb * entry_size, table_hash, merkle, feature_crc))
        end_pos = f.tell()
        f.seek(0)
        f.write(HEADER.pack(MAGIC, VERSION, flags, cfg.target_bucket_kb, nb, table_ofs))
        f.seek(end_pos)
        manifest = {
            "nbuckets": nb,
            "schema": 0,
            "flags": flags,
            "target_bucket_kb": cfg.target_bucket_kb,
            "compressor": "zstd" if (flags & FLAG_ZSTD) else "zlib",
            "aesgcm": bool(flags & FLAG_AESGCM),
            "column": bool(flags & FLAG_COLUMN),
            "varint": bool(flags & FLAG_VARINT),
            "bloom_bits": cfg.bloom_bits,
        }
        man_bytes = json.dumps(manifest, separators=(",", ":")).encode("utf-8")
        f.write(man_bytes)
        f.write(struct.pack("<I", len(man_bytes)))
    return {
        "file_mb": os.path.getsize(path) / (1024 * 1024),
        "nbuckets": nb,
        "bucket_kb": cfg.target_bucket_kb,
        "flags": flags,
    }

@dataclass
class Reader:
    path: Path
    flags: int
    bucket_kb: int
    table_pos: int
    nbuckets: int
    entry_size: int
    index: List[Tuple[int, int, int, int]]
    blooms: List[bytes]
    f: io.BufferedReader

def open_reader(path: Path) -> Reader:
    f = open(path, "rb")
    hdr = f.read(HEADER.size)
    magic, ver, flags, bucket_kb, nb, table_pos = HEADER.unpack(hdr)
    assert magic == MAGIC and ver == VERSION, "Invalid MBT2 file"
    try:
        f.seek(-4, os.SEEK_END)
        mlen = struct.unpack("<I", f.read(4))[0]
        f.seek(-4 - mlen, os.SEEK_END)
        man_bytes = f.read(mlen)
        manifest = json.loads(man_bytes)
        bloom_bits = manifest.get("bloom_bits", 2048)
    except Exception:
        bloom_bits = 2048
    bloom_bytes = bloom_bits // 8
    entry_size = ENTRY.size + bloom_bytes
    f.seek(table_pos)
    index = []
    blooms = []
    for _ in range(nb):
        start, count, off, length, xx, sh, bb, stats_off = ENTRY.unpack(f.read(ENTRY.size))
        bloom = f.read(bb)
        index.append((start, count, off, length))
        blooms.append(bloom)
    return Reader(Path(path), flags, bucket_kb, table_pos, nb, entry_size, index, blooms, f)

def _bucket_for(index: List[Tuple[int, int, int, int]], key: int) -> int:
    lo, hi = 0, len(index) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if index[mid][0] <= key and (mid == len(index) - 1 or index[mid + 1][0] > key):
            return mid
        if index[mid][0] < key:
            lo = mid + 1
        else:
            hi = mid - 1
    return max(0, min(len(index) - 1, lo))

def lookup(reader: Reader, x: int, y: int, z: int, aes_key: Optional[bytes] = None) -> Optional[Tuple[float, float, float]]:
    key = morton64(x, y, z)
    i = _bucket_for(reader.index, key)
    start, count, off, length = reader.index[i]
    bloom = reader.blooms[i]
    if not _bloom_maybe(bloom, key, 8 * len(bloom)):
        return None
    reader.f.seek(off)
    comp = reader.f.read(length)
    comp = _maybe_decrypt(aes_key if (reader.flags & FLAG_AESGCM) else None, comp, struct.pack("<I", i))
    raw = _decompress(comp)
    p = 0
    first = struct.unpack_from("<Q", raw, p)[0]
    p += 8
    cur = first
    pos = 0
    while pos < count and cur < key:
        d, p = dec_varint(raw, p)
        cur += d
        pos += 1
    if cur != key:
        return None
    for _ in range(pos, count - 1):
        _, p = dec_varint(raw, p)
    fsz = 4 * count
    masses_off = p
    ents_off = p + fsz
    taus_off = p + 2 * fsz
    j = pos
    mass = struct.unpack_from("<f", raw, masses_off + 4 * j)[0]
    ent = struct.unpack_from("<f", raw, ents_off + 4 * j)[0]
    tau = struct.unpack_from("<f", raw, taus_off + 4 * j)[0]
    return mass, ent, tau

def full_scan(reader: Reader) -> Tuple[int, float]:
    total = 0
    mass_sum = 0.0
    for (start, count, off, length), bloom in zip(reader.index, reader.blooms):
        reader.f.seek(off)
        comp = reader.f.read(length)
        raw = _decompress(comp)
        p = 8
        for _ in range(count - 1):
            _, p = dec_varint(raw, p)
        masses = struct.unpack_from(f"<{count}f", raw, p)
        total += count
        mass_sum += float(sum(masses))
    return total, mass_sum

# -----------------------------------------------------------------------------
# Generic .gmw archive helpers

def compress_folder_to_gmw(folder_path: str, output_path: str, use_zstd: bool = True, zstd_level: int = 3) -> None:
    folder = Path(folder_path)
    output = Path(output_path)
    assert folder.is_dir(), f"{folder_path} is not a directory"
    buf = io.BytesIO()
    with tarfile.open(fileobj=buf, mode="w") as tf:
        tf.add(folder, arcname=".")
    tar_data = buf.getvalue()
    if use_zstd and HAS_ZSTD:
        comp = zstd.ZstdCompressor(level=zstd_level).compress(tar_data)
    else:
        comp = zlib.compress(tar_data, 6)
    with open(output, "wb") as out_f:
        out_f.write(comp)

def extract_gmw(gmw_path: str, output_dir: str) -> None:
    gmw_file = Path(gmw_path)
    out_dir = Path(output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)
    comp_data = gmw_file.read_bytes()
    if HAS_ZSTD and len(comp_data) >= 4 and comp_data[:4] == b"\x28\xB5\x2F\xFD":
        tar_data = zstd.ZstdDecompressor().decompress(comp_data)
    else:
        tar_data = zlib.decompress(comp_data)
    with io.BytesIO(tar_data) as buf:
        with tarfile.open(fileobj=buf, mode="r") as tf:
            tf.extractall(path=out_dir)

# -----------------------------------------------------------------------------
# Simple interactive commandâ€‘line interface

def main() -> None:
    parser = argparse.ArgumentParser(description="GMW Archive Tool")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Compress command
    compress_parser = subparsers.add_parser("compress", help="Compress a folder into a .gmw archive")
    compress_parser.add_argument("input_folder", help="Path to the folder to compress")
    compress_parser.add_argument("output_gmw", help="Output .gmw file name")
    compress_parser.add_argument("--zstd-level", type=int, default=3, help="Zstandard compression level (1-19)")
    compress_parser.add_argument("--threads", type=int, default=max(1, os.cpu_count() or 1), help="Number of threads to use for compression")

    # Extract command
    extract_parser = subparsers.add_parser("extract", help="Extract a .gmw archive into a folder")
    extract_parser.add_argument("input_gmw", help="Path to the .gmw file to extract")
    extract_parser.add_argument("output_folder", help="Output folder for extraction")

    args = parser.parse_args()

    if args.command == "compress":
        if not args.output_gmw.endswith(".gmw"):
            args.output_gmw += ".gmw"
        try:
            # Note: compress_folder_to_gmw doesn't directly support MBT2 config,
            #       but we'll pass the args for potential future use or a different compression function
            compress_folder_to_gmw(args.input_folder, args.output_gmw, use_zstd=True, zstd_level=args.zstd_level)
            print(f"Folder '{args.input_folder}' compressed into '{args.output_gmw}'.")
        except Exception as e:
            print("Error during compression:", e)
    elif args.command == "extract":
        try:
            extract_gmw(args.input_gmw, args.output_folder)
            print(f"Archive '{args.input_gmw}' extracted into '{args.output_folder}'.")
        except Exception as e:
            print("Error during extraction:", e)
    else:
        parser.print_help()

        Integrate metadata and integrity in generic archiver
Subtask:
Modify compress_folder_to_gmw to add a JSON footer with metadata and a checksum, and update extract_gmw to use this footer for compressor detection and integrity verification.

Reasoning: I need to modify the compress_folder_to_gmw function to add a JSON footer with metadata and a checksum and the extract_gmw function to read and verify this footer. I will group these modifications into a single code block.


def compress_folder_to_gmw(folder_path: str, output_path: str, use_zstd: bool = True, zstd_level: int = 3) -> None:
    folder = Path(folder_path)
    output = Path(output_path)
    assert folder.is_dir(), f"{folder_path} is not a directory"

    buf = io.BytesIO()
    with tarfile.open(fileobj=buf, mode="w") as tf:
        tf.add(folder, arcname=".")
    tar_data = buf.getvalue()

    if use_zstd and HAS_ZSTD:
        comp = zstd.ZstdCompressor(level=zstd_level).compress(tar_data)
        compressor_name = "zstd"
    else:
        comp = zlib.compress(tar_data, 6)
        compressor_name = "zlib"

    # Calculate checksum of compressed data
    checksum = hashlib.sha256(comp).hexdigest()

    # Create metadata dictionary
    metadata = {
        "compressor": compressor_name,
        "zstd_level": zstd_level if compressor_name == "zstd" else None,
        "checksum": checksum,
        "checksum_algorithm": "sha256"
    }

    # Serialize metadata to JSON and encode
    metadata_bytes = json.dumps(metadata, separators=(",", ":")).encode("utf-8")
    metadata_length = struct.pack("<I", len(metadata_bytes))

    # Write compressed data, metadata, and metadata length to the output file
    with open(output, "wb") as out_f:
        out_f.write(comp)
        out_f.write(metadata_bytes)
        out_f.write(metadata_length)


def extract_gmw(gmw_path: str, output_dir: str) -> None:
    gmw_file = Path(gmw_path)
    out_dir = Path(output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    with open(gmw_file, "rb") as in_f:
        # Read metadata length from the end of the file
        in_f.seek(-4, os.SEEK_END)
        metadata_length = struct.unpack("<I", in_f.read(4))[0]

        # Read metadata
        in_f.seek(-4 - metadata_length, os.SEEK_END)
        metadata_bytes = in_f.read(metadata_length)
        metadata = json.loads(metadata_bytes)

        # Get compressor information and expected checksum
        compressor_name = metadata.get("compressor")
        expected_checksum = metadata.get("checksum")
        checksum_algorithm = metadata.get("checksum_algorithm", "sha256") # Default to sha256

        # Read compressed data (excluding metadata and its length)
        in_f.seek(0)
        comp_data = in_f.read(os.path.getsize(gmw_file) - metadata_length - 4)

    # Verify checksum of the compressed data
    if checksum_algorithm == "sha256":
        actual_checksum = hashlib.sha256(comp_data).hexdigest()
    elif checksum_algorithm == "xxhash64" and HAS_XX:
         actual_checksum = xxhash.xxh64(comp_data).hexdigest()
    else:
        raise ValueError(f"Unsupported or unavailable checksum algorithm: {checksum_algorithm}")


    if actual_checksum != expected_checksum:
        raise ValueError(f"Checksum mismatch! Expected: {expected_checksum}, Got: {actual_checksum}")

    # Decompress data based on metadata
    if compressor_name == "zstd" and HAS_ZSTD:
        tar_data = zstd.ZstdDecompressor().decompress(comp_data)
    elif compressor_name == "zlib":
        tar_data = zlib.decompress(comp_data)
    else:
        raise ValueError(f"Unsupported or unavailable compressor: {compressor_name}")

    # Extract tar data
    with io.BytesIO(tar_data) as buf:
        with tarfile.open(fileobj=buf, mode="r") as tf:
            tf.extractall(path=out_dir)


Enhance mbt2 engine
Subtask:
Enhance the MBT2 engine by autotuning the target bucket size only when explicitly set to 0 and by introducing a dataclass for MBT2 records for better code readability.

Reasoning: I need to modify the write_mbt2 function to autotune the bucket size only if cfg.target_bucket_kb is 0 or less. I also need to define a MBT2Record dataclass and update the type hints for records in write_mbt2 and the return type of _build_buckets. I will also need to update the packing/unpacking logic to use the new dataclass. I will perform these changes in a single code block.



@dataclass
class MBT2Record:
    """Represents a single MBT2 record with physics components."""
    key: int     # Morton key (space)
    mass: float  # Motion (resistance)
    entropy: float # Entropy (time)
    tau: float   # Curvature memory (time-space)

def _pack_bucket(records: List[MBT2Record], column: bool = True) -> bytes:
    n = len(records)
    if n == 0:
        return b""
    out = bytearray()
    out += struct.pack("<Q", records[0].key)
    prev = records[0].key
    for i in range(1, n):
        d = records[i].key - prev
        out += enc_varint(d)
        prev = records[i].key
    if column:
        out += struct.pack(f"<{n}f", *[r.mass for r in records])
        out += struct.pack(f"<{n}f", *[r.entropy for r in records])
        out += struct.pack(f"<{n}f", *[r.tau for r in records])
    else:
        for r in records:
            out += struct.pack("<fff", r.mass, r.entropy, r.tau)
    return bytes(out)

def _build_buckets(sorted_recs: List[MBT2Record], target_kb: int) -> List[List[MBT2Record]]:
    target = target_kb * 1024
    out: List[List[MBT2Record]] = []
    current_bucket: List[MBT2Record] = []
    size = 0
    for rec in sorted_recs:
        # Estimate size: 8 bytes for first key + varint diffs (avg ~3 bytes) + 12 bytes for 3 floats
        add = (3 if current_bucket else 8) + 12
        if size + add > target and current_bucket:
            out.append(current_bucket)
            current_bucket = []
            size = 0
        current_bucket.append(rec)
        size += add
    if current_bucket:
        out.append(current_bucket)
    return out

def write_mbt2(path: Path, records: List[MBT2Record], cfg: WriterCfg = WriterCfg()) -> Dict:
    path = Path(path)
    t_sort0 = time.perf_counter()
    records.sort(key=lambda r: r.key)
    t_sort = time.perf_counter() - t_sort0
    # Autotune only if target_bucket_kb is not set (<= 0)
    if cfg.target_bucket_kb <= 0:
        cfg.target_bucket_kb = _autotune_bucket_kb(len(records))
    buckets = _build_buckets(records, cfg.target_bucket_kb)
    nb = len(buckets)
    flags = 0
    flags |= FLAG_ZSTD if (cfg.use_zstd and HAS_ZSTD) else FLAG_ZLIB
    flags |= FLAG_VARINT
    if cfg.column_layout:
        flags |= FLAG_COLUMN
    if cfg.aesgcm_key and HAS_AESGCM:
        flags |= FLAG_AESGCM
    with open(path, "w+b") as f:
        f.write(HEADER.pack(MAGIC, VERSION, flags, cfg.target_bucket_kb, nb, 0))
        header_end = f.tell()
        bloom_bytes = cfg.bloom_bits // 8
        entry_size = ENTRY.size + bloom_bytes
        table_ofs = header_end
        f.seek(table_ofs + nb * entry_size)
        metas = []
        lock = threading.Lock()
        def write_bucket(i: int, b: List[MBT2Record]) -> None:
            raw = _pack_bucket(b, column=bool(flags & FLAG_COLUMN))
            comp = _compress(raw, zstd_on=bool(flags & FLAG_ZSTD), lvl=cfg.zstd_level)
            comp = _maybe_encrypt(cfg.aesgcm_key if (flags & FLAG_AESGCM) else None, comp, aad=struct.pack("<I", i))
            xx = _xx64(comp)
            sh = hashlib.sha256(comp).digest() if cfg.sha256_each else b"\x00" * 32
            bloom = bytearray(bloom_bytes)
            for rec in b:
                _bloom_add(bloom, rec.key, cfg.bloom_bits)
            with lock:
                pos = f.tell()
                f.write(comp)
                metas.append((b[0].key, len(b), pos, len(comp), xx, sh, bytes(bloom)))
        t_comp0 = time.perf_counter()
        with ThreadPoolExecutor(max_workers=cfg.threads) as ex:
            futs = [ex.submit(write_bucket, i, b) for i, b in enumerate(buckets)]
            for fu in as_completed(futs):
                fu.result()
        t_comp = time.perf_counter() - t_comp0
        metas.sort(key=lambda m: m[0])
        data_end = f.tell()
        f.seek(table_ofs)
        for (start, count, off, length, xx, sh, bloom) in metas:
            f.write(ENTRY.pack(start, count, off, length, xx, sh, len(bloom), 0))
            f.write(bloom)
        f.seek(table_ofs)
        table_blob = f.read(nb * entry_size)
        table_hash = hashlib.sha256(table_blob).digest()
        leaves = [sh if cfg.sha256_each else xx.to_bytes(8, "little") for (_, _, _, _, xx, sh, _) in metas]
        if leaves:
            cur = [hashlib.sha256(x).digest() if len(x) != 32 else x for x in leaves]
            while len(cur) > 1:
                nxt = []
                for i in range(0, len(cur), 2):
                    a = cur[i]
                    b = cur[i + 1] if i + 1 < len(cur) else a
                    nxt.append(hashlib.sha256(a + b).digest())
                cur = nxt
            merkle = cur[0]
        else:
            merkle = b"\x00" * 32
        f.seek(data_end)
        feature_crc = zlib.crc32(struct.pack("<IHH", VERSION, cfg.target_bucket_kb, flags)) & 0xFFFFFFFF
        f.write(FOOTER.pack(nb * entry_size, table_hash, merkle, feature_crc))
        end_pos = f.tell()
        f.seek(0)
        f.write(HEADER.pack(MAGIC, VERSION, flags, cfg.target_bucket_kb, nb, table_ofs))
        f.seek(end_pos)
        manifest = {
            "nbuckets": nb,
            "schema": 0,
            "flags": flags,
            "target_bucket_kb": cfg.target_bucket_kb,
            "compressor": "zstd" if (flags & FLAG_ZSTD) else "zlib",
            "aesgcm": bool(flags & FLAG_AESGCM),
            "column": bool(flags & FLAG_COLUMN),
            "varint": bool(flags & FLAG_VARINT),
            "bloom_bits": cfg.bloom_bits,
        }
        man_bytes = json.dumps(manifest, separators=(",", ":")).encode("utf-8")
        f.write(man_bytes)
        f.write(struct.pack("<I", len(man_bytes)))
    return {
        "file_mb": os.path.getsize(path) / (1024 * 1024),
        "nbuckets": nb,
        "bucket_kb": cfg.target_bucket_kb,
        "flags": flags,
    }

def lookup(reader: Reader, x: int, y: int, z: int, aes_key: Optional[bytes] = None) -> Optional[Tuple[float, float, float]]:
    key = morton64(x, y, z)
    i = _bucket_for(reader.index, key)
    start, count, off, length = reader.index[i]
    bloom = reader.blooms[i]
    if not _bloom_maybe(bloom, key, 8 * len(bloom)):
        return None
    reader.f.seek(off)
    comp = reader.f.read(length)
    comp = _maybe_decrypt(aes_key if (reader.flags & FLAG_AESGCM) else None, comp, struct.pack("<I", i))
    raw = _decompress(comp)
    p = 0
    # Read first key (8 bytes)
    first_key = struct.unpack_from("<Q", raw, p)[0]
    p += 8

    # Read varint key differences
    keys = [first_key]
    cur_key = first_key
    for _ in range(count - 1):
        d, p = dec_varint(raw, p)
        cur_key += d
        keys.append(cur_key)

    try:
        # Find the index of the target key within this bucket
        j = keys.index(key)
    except ValueError:
        # Key not found in this bucket
        return None

    # Calculate offsets for column layout
    fsz = 4 * count
    masses_off = p
    ents_off = p + fsz
    taus_off = p + 2 * fsz

    # Extract the float values for the found key
    mass = struct.unpack_from("<f", raw, masses_off + 4 * j)[0]
    ent = struct.unpack_from("<f", raw, ents_off + 4 * j)[0]
    tau = struct.unpack_from("<f", raw, taus_off + 4 * j)[0]

    return mass, ent, tau

def full_scan(reader: Reader) -> Tuple[int, float]:
    total = 0
    mass_sum = 0.0
    for (start, count, off, length), bloom in zip(reader.index, reader.blooms):
        reader.f.seek(off)
        comp = reader.f.read(length)
        raw = _decompress(comp)
        p = 0
        # Skip first key (8 bytes)
        p += 8
        # Skip varint key differences
        for _ in range(count - 1):
            _, p = dec_varint(raw, p)

        # Read masses (assuming column layout for simplicity in full scan)
        # If row layout was used, we would need to iterate through records.
        # The current full_scan only calculates total records and sum of masses,
        # which is easier with column layout.
        # If row layout needs full scan of all fields, adjust this part.
        fsz = 4 * count
        masses_off = p
        masses = struct.unpack_from(f"<{count}f", raw, masses_off)

        total += count
        mass_sum += float(sum(masses))
    return total, mass_sum

    Add progress bar
Subtask:
Integrate a progress bar (e.g., using tqdm) for folder compression/extraction to provide visual feedback to the user.

Reasoning: Import the tqdm library to enable progress bars.

from tqdm import tqdm


Reasoning: Wrap the tar archiving process in compress_folder_to_gmw with tqdm to show progress.

def compress_folder_to_gmw(folder_path: str, output_path: str, use_zstd: bool = True, zstd_level: int = 3) -> None:
    folder = Path(folder_path)
    output = Path(output_path)
    assert folder.is_dir(), f"{folder_path} is not a directory"

    buf = io.BytesIO()
    # Estimate the number of files for tqdm progress bar
    file_count = sum(len(files) for _, _, files in os.walk(folder))

    with tarfile.open(fileobj=buf, mode="w") as tf:
        with tqdm(total=file_count, unit='file', desc=f'Compressing {folder.name}') as pbar:
            for root, _, files in os.walk(folder):
                for file in files:
                    file_path = Path(root) / file
                    tf.add(file_path, arcname=file_path.relative_to(folder))
                    pbar.update(1)

    tar_data = buf.getvalue()

    if use_zstd and HAS_ZSTD:
        comp = zstd.ZstdCompressor(level=zstd_level).compress(tar_data)
        compressor_name = "zstd"
    else:
        comp = zlib.compress(tar_data, 6)
        compressor_name = "zlib"

    # Calculate checksum of compressed data
    checksum = hashlib.sha256(comp).hexdigest()

    # Create metadata dictionary
    metadata = {
        "compressor": compressor_name,
        "zstd_level": zstd_level if compressor_name == "zstd" else None,
        "checksum": checksum,
        "checksum_algorithm": "sha256"
    }

    # Serialize metadata to JSON and encode
    metadata_bytes = json.dumps(metadata, separators=(",", ":")).encode("utf-8")
    metadata_length = struct.pack("<I", len(metadata_bytes))

    # Write compressed data, metadata, and metadata length to the output file
    with open(output, "wb") as out_f:
        out_f.write(comp)
        out_f.write(metadata_bytes)
        out_f.write(metadata_length)

def extract_gmw(gmw_path: str, output_dir: str) -> None:
    gmw_file = Path(gmw_path)
    out_dir = Path(output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    with open(gmw_file, "rb") as in_f:
        # Read metadata length from the end of the file
        in_f.seek(-4, os.SEEK_END)
        metadata_length = struct.unpack("<I", in_f.read(4))[0]

        # Read metadata
        in_f.seek(-4 - metadata_length, os.SEEK_END)
        metadata_bytes = in_f.read(metadata_length)
        metadata = json.loads(metadata_bytes)

        # Get compressor information and expected checksum
        compressor_name = metadata.get("compressor")
        expected_checksum = metadata.get("checksum")
        checksum_algorithm = metadata.get("checksum_algorithm", "sha256") # Default to sha256

        # Read compressed data (excluding metadata and its length)
        in_f.seek(0)
        comp_data = in_f.read(os.path.getsize(gmw_file) - metadata_length - 4)

    # Verify checksum of the compressed data
    if checksum_algorithm == "sha256":
        actual_checksum = hashlib.sha256(comp_data).hexdigest()
    elif checksum_algorithm == "xxhash64" and HAS_XX:
         actual_checksum = xxhash.xxh64(comp_data).hexdigest()
    else:
        raise ValueError(f"Unsupported or unavailable checksum algorithm: {checksum_algorithm}")


    if actual_checksum != expected_checksum:
        raise ValueError(f"Checksum mismatch! Expected: {expected_checksum}, Got: {actual_checksum}")

    # Decompress data based on metadata
    if compressor_name == "zstd" and HAS_ZSTD:
        tar_data = zstd.ZstdDecompressor().decompress(comp_data)
    elif compressor_name == "zlib":
        tar_data = zlib.decompress(comp_data)
    else:
        raise ValueError(f"Unsupported or unavailable compressor: {compressor_name}")

    # Extract tar data with progress bar
    with io.BytesIO(tar_data) as buf:
        with tarfile.open(fileobj=buf, mode="r") as tf:
            total_members = len(tf.getmembers())
            with tqdm(total=total_members, unit='file', desc=f'Extracting to {out_dir.name}') as pbar:
                for member in tf.getmembers():
                    tf.extract(member, path=out_dir)
                    pbar.update(1)


                  Refactor and clean up
Subtask:
Review the code for any necessary refactoring or cleanup after implementing the changes.

Reasoning: Review the code for any necessary refactoring or cleanup after implementing the changes, consolidate similar functionalities into shared helper functions if appropriate, review variable names and function names for clarity and consistency, add or update comments and docstrings to reflect the changes made and improve code understanding, and ensure consistent code formatting and style throughout the script.


 Summary:
Data Analysis Key Findings
The main function was successfully updated to use argparse for handling command-line arguments for compress and extract operations, replacing interactive input.
The compress_folder_to_gmw function was enhanced to include a JSON footer containing metadata (compressor type, level, checksum) and its length, written at the end of the file.
The extract_gmw function was modified to read the JSON footer, detect the compressor type, and perform a SHA256 checksum verification of the compressed data before decompression.
A new dataclass, MBT2Record, was introduced to represent MBT2 records with key, mass, entropy, and tau fields, improving code readability.
The write_mbt2 function was updated to use the MBT2Record dataclass and to autotune the target bucket size only when the target_bucket_kb configuration is explicitly set to 0.
Progress bars using tqdm were successfully integrated into both the compress_folder_to_gmw and extract_gmw functions to provide visual feedback during file processing.
A review of the code structure determined that no further significant refactoring was needed within the scope of the task.
Insights or Next Steps
Consider adding support for other checksum algorithms (e.g., xxHash) in the GMW footer for potentially faster integrity checks.
Explore implementing a progress bar for the MBT2 writing process, particularly for the bucket compression phase, to provide feedback during that potentially time-consuming step.

Task
Generate synthetic audio, text, and other data, compress it using the provided gmw tool.py script and standard compression methods, and benchmark the compression ratio and time for both methods.

Generate synthetic data
Subtask:
Create functions or use libraries to generate synthetic data for audio, text, and potentially other types like images or simple structured data.

Reasoning: The subtask requires generating synthetic data of different types. I will define a function generate_synthetic_data that takes the data type and size as input and generates the data accordingly using appropriate libraries.

import numpy as np
import pandas as pd
from PIL import Image
import io
import random
import string
import wave
import struct

def generate_synthetic_data(data_type, size):
    """Generates synthetic data of different types.

    Args:
        data_type (str): The type of data to generate ('audio', 'text', 'image', 'structured').
        size (int): The size or complexity of the data (interpretation varies by type).

    Returns:
        The generated data in a suitable format.
    """
    if data_type == 'audio':
        # Generate simple sine wave audio
        sample_rate = 44100
        duration = size  # size in seconds
        frequency = 440  # A4 note
        n_samples = int(sample_rate * duration)
        amplitude = 16000
        data = b''
        with io.BytesIO() as buf:
            with wave.open(buf, 'wb') as wf:
                wf.setnchannels(1)
                wf.setsampwidth(2)
                wf.setframerate(sample_rate)
                for i in range(n_samples):
                    value = int(amplitude * np.sin(2 * np.pi * frequency * i / sample_rate))
                    data += struct.pack('<h', value)
                wf.writeframes(data)
            return buf.getvalue()
    elif data_type == 'text':
        # Generate random text
        characters = string.ascii_letters + string.digits + string.punctuation + string.whitespace
        return ''.join(random.choice(characters) for i in range(size))
    elif data_type == 'image':
        # Generate a simple image with random pixels
        width, height = size, size  # size is the dimension
        img_array = np.random.randint(0, 256, (height, width, 3), dtype=np.uint8)
        img = Image.fromarray(img_array, 'RGB')
        img_byte_arr = io.BytesIO()
        img.save(img_byte_arr, format='PNG')
        return img_byte_arr.getvalue()
    elif data_type == 'structured':
        # Generate a simple pandas DataFrame
        data = {'col1': np.random.rand(size),
                'col2': np.random.randint(0, 100, size),
                'col3': [random.choice(['A', 'B', 'C']) for _ in range(size)]}
        df = pd.DataFrame(data)
        return df.to_csv(index=False).encode('utf-8')
    else:
        raise ValueError(f"Unknown data type: {data_type}")








# gmw_tool.py - Stand-alone script providing GMW archive functionality.

# This single Python script includes:

# 1. The MBT2 storage implementation for voxel data (with recommended
#    defaults for maximal compaction) - this allows writing and reading
#    voxel records using Z-order keys.  The code is derived from
#    `mbt_gmw.py` and is included here verbatim for convenience.

# 2. Convenience functions `compress_folder_to_gmw` and
#    `extract_gmw` for packaging arbitrary directory trees into a
#    `.gmw` file and extracting them back.  A `.gmw` file in this
#    context is a tar archive compressed with Zstandard (if available)
#    or zlib and suffixed with the `.gmw` extension.

# 3. A simple interactive command-line interface that runs when the
#    script is executed directly.  The user is prompted to choose
#    whether to compress a folder or extract a `.gmw` archive and to
#    provide the relevant paths.  This makes the script usable
#    out-of-the-box without any additional code.

# Usage:
#     python gmw_tool.py

# The script will prompt the user to select an action and enter
# input/output paths.  It relies only on the Python standard library and
# optionally the `zstandard` module for faster compression and smaller
# archives.  If `zstandard` is not installed, zlib will be used.


import os
import io
import tarfile
import struct
import json
import time
import threading
import zlib
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple, Optional, Iterable, Dict
from concurrent.futures import ThreadPoolExecutor, as_completed

try:
    import zstandard as zstd  # optional
    HAS_ZSTD = True
except Exception:
    zstd = None
    HAS_ZSTD = False

try:
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM  # optional
    HAS_AESGCM = True
except Exception:
    AESGCM = None
    HAS_AESGCM = False

try:
    import xxhash
    HAS_XX = True
except Exception:
    xxhash = None
    HAS_XX = False

import hashlib # Import hashlib as it's used in _xx64 and write_mbt2


# -----------------------------------------------------------------------------
# Morton encoding helpers for voxel keys

_DILATE16 = [0] * 65536

def _init_dilate():
    for i in range(65536):
        n = i
        n = (n | (n << 16)) & 0x0000FFFF0000FFFF
        n = (n | (n << 8)) & 0x00FF00FF00FF00FF
        n = (n | (n << 4)) & 0x0F0F0F0F0F0F0F0F
        n = (n | (n << 2)) & 0x3333333333333333
        n = (n | (n << 1)) & 0x5555555555555555
        _DILATE16[i] = n

_init_dilate()

def morton64(x: int, y: int, z: int) -> int:
    x &= 0x1FFFFF
    y &= 0x1FFFFF
    z &= 0x1FFFFF
    xx = _DILATE16[x & 0xFFFF] | (_DILATE16[(x >> 16) & 0xFFFF] << 32)
    yy = _DILATE16[y & 0xFFFF] | (_DILATE16[(y >> 16) & 0xFFFF] << 32)
    zz = _DILATE16[z & 0xFFFF] | (_DILATE16[(z >> 16) & 0xFFFF] << 32)
    return (xx | (yy << 1) | (zz << 2)) & ((1 << 64) - 1)

def inv_morton64(k: int) -> Tuple[int, int, int]:
    def compact(n: int) -> int:
        n &= 0x5555555555555555
        n = (n | (n >> 1)) & 0x3333333333333333
        n = (n | (n >> 2)) & 0x0F0F0F0F0F0F0F0F
        n = (n | (n >> 4)) & 0x00FF00FF00FF00FF
        n = (n | (n >> 8)) & 0x0000FFFF0000FFFF
        n = (n | (n >> 16)) & 0x00000000FFFFFFFF
        return n
    x = compact(k) & 0x1FFFFF
    y = compact(k >> 1) & 0x1FFFFF
    z = compact(k >> 2) & 0x1FFFFF
    return x, y, z

# Varint helpers

def enc_varint(n: int) -> bytes:
    out = bytearray()
    while True:
        b = n & 0x7F
        n >>= 7
        if n:
            out.append(0x80 | b)
        else:
            out.append(b)
            break
    return bytes(out)

def dec_varint(buf: bytes, off: int) -> Tuple[int, int]:
    shift = 0
    val = 0
    while True:
        b = buf[off]
        off += 1
        val |= (b & 0x7F) << shift
        if not (b & 0x80):
            break
        shift += 7
    return val, off

# Bloom filter hash (deterministic)

def _bloom_hash(key: int, i: int) -> int:
    x = (key + 0x9E3779B97F4A7C15 + i) & 0xFFFFFFFFFFFFFFFF
    x = (x ^ (x >> 30)) * 0xBF58476D1CE4E5B9 & 0xFFFFFFFFFFFFFFFF
    x = (x ^ (x >> 27)) * 0x94D049BB133111EB & 0xFFFFFFFFFFFFFFFF
    x = x ^ (x >> 31)
    return x & 0xFFFFFFFF

def _bloom_add(bits: bytearray, key: int, m: int, h: int = 3) -> None:
    for i in range(h):
        hv = _bloom_hash(key, i) % m
        bits[hv // 8] |= 1 << (hv % 8)

def _bloom_maybe(bits: bytes, key: int, m: int, h: int = 3) -> bool:
    for i in range(h):
        hv = _bloom_hash(key, i) % m
        if not (bits[hv // 8] & (1 << (hv % 8))):
            return False
    return True

# Format constants

MAGIC = b"MBT2\0"
VERSION = 2

FLAG_ZLIB = 1 << 0
FLAG_ZSTD = 1 << 1
FLAG_AESGCM = 1 << 2
FLAG_VARINT = 1 << 3
FLAG_COLUMN = 1 << 4
FLAG_HILBERT = 1 << 5
FLAG_KEY_128 = 1 << 6

HEADER = struct.Struct("<5sB I H I Q")
ENTRY = struct.Struct("<Q I Q I Q 32s H I")
FOOTER = struct.Struct("<I 32s 32s I")

@dataclass
class WriterCfg:
    """Recommended configuration for writing MBT2 archives."""
    target_bucket_kb: int = 128
    use_zstd: bool = True
    zstd_level: int = 3
    threads: int = max(1, os.cpu_count() or 1)
    aesgcm_key: Optional[bytes] = None
    sha256_each: bool = False
    bloom_bits: int = 2048
    column_layout: bool = True

def _compress(raw: bytes, zstd_on: bool, lvl: int = 3) -> bytes:
    if zstd_on and HAS_ZSTD:
        return zstd.ZstdCompressor(level=lvl).compress(raw)
    return zlib.compress(raw, 6)

def _decompress(comp: bytes) -> bytes:
    if HAS_ZSTD and len(comp) >= 4 and comp[:4] == b"\x28\xB5\x2F\xFD":
        return zstd.ZstdDecompressor().decompress(comp)
    return zlib.decompress(comp)

def _maybe_encrypt(aes_key: Optional[bytes], data: bytes, aad: bytes) -> bytes:
    if not aes_key or not HAS_AESGCM:
        return data
    nonce = os.urandom(12)
    return nonce + AESGCM(aes_key).encrypt(nonce, data, aad)

def _maybe_decrypt(aes_key: Optional[bytes], data: bytes, aad: bytes) -> bytes:
    if not aes_key or not HAS_AESGCM:
        return data
    nonce, ct = data[:12], data[12:]
    return AESGCM(aes_key).decrypt(nonce, ct, aad)

def _xx64(b: bytes) -> int:
    if HAS_XX:
        return xxhash.xxh64(b).intdigest()
    return int.from_bytes(hashlib.blake2b(b, digest_size=8).digest(), "little")

def _autotune_bucket_kb(n: int, approx_rec_bytes: int = 20) -> int:
    recs = max(4096, min(12288, n // 80))
    kb = max(64, min(256, (recs * approx_rec_bytes) // 1024))
    return int(kb)

def _pack_bucket(keys: List[int], masses: List[float], ents: List[float], taus: List[float], column: bool = True) -> bytes:
    n = len(keys)
    if n == 0:
        return b""
    out = bytearray()
    out += struct.pack("<Q", keys[0])
    prev = keys[0]
    for i in range(1, n):
        d = keys[i] - prev
        out += enc_varint(d)
        prev = keys[i]
    if column:
        out += struct.pack(f"<{n}f", *masses)
        out += struct.pack(f"<{n}f", *ents)
        out += struct.pack(f"<{n}f", *taus)
    else:
        for i in range(n):
            out += struct.pack("<fff", masses[i], ents[i], taus[i])
    return bytes(out)

def _build_buckets(sorted_recs: List[Tuple[int, float, float, float]], target_kb: int) -> List[Tuple[List[int], List[float], List[float], List[float]]]:
    target = target_kb * 1024
    out = []
    ks: List[int] = []
    ms: List[float] = []
    es: List[float] = []
    ts: List[float] = []
    size = 0
    for k, m, e, t in sorted_recs:
        add = (3 if ks else 8) + 12
        if size + add > target and ks:
            out.append((ks, ms, es, ts))
            ks, ms, es, ts = [], [], [], []
            size = 0
        ks.append(k)
        ms.append(m)
        es.append(e)
        ts.append(t)
        size += add
    if ks:
        out.append((ks, ms, es, ts))
    return out

def write_mbt2(path: Path, records: List[Tuple[int, float, float, float]], cfg: WriterCfg = WriterCfg()) -> Dict:
    path = Path(path)
    t_sort0 = time.perf_counter()
    records.sort(key=lambda r: r[0])
    t_sort = time.perf_counter() - t_sort0
    if cfg.target_bucket_kb <= 0:
        cfg.target_bucket_kb = _autotune_bucket_kb(len(records))
    buckets = _build_buckets(records, cfg.target_bucket_kb)
    nb = len(buckets)
    flags = 0
    flags |= FLAG_ZSTD if (cfg.use_zstd and HAS_ZSTD) else FLAG_ZLIB
    flags |= FLAG_VARINT
    if cfg.column_layout:
        flags |= FLAG_COLUMN
    if cfg.aesgcm_key and HAS_AESGCM:
        flags |= FLAG_AESGCM
    with open(path, "w+b") as f:
        f.write(HEADER.pack(MAGIC, VERSION, flags, cfg.target_bucket_kb, nb, 0))
        header_end = f.tell()
        bloom_bytes = cfg.bloom_bits // 8
        entry_size = ENTRY.size + bloom_bytes
        table_ofs = header_end
        f.seek(table_ofs + nb * entry_size)
        metas = []
        lock = threading.Lock()
        def write_bucket(i: int, b) -> None:
            ks, ms, es, ts = b
            raw = _pack_bucket(ks, ms, es, ts, column=bool(flags & FLAG_COLUMN))
            comp = _compress(raw, zstd_on=bool(flags & FLAG_ZSTD), lvl=cfg.zstd_level)
            comp = _maybe_encrypt(cfg.aesgcm_key if (flags & FLAG_AESGCM) else None, comp, aad=struct.pack("<I", i))
            xx = _xx64(comp)
            sh = hashlib.sha256(comp).digest() if cfg.sha256_each else b"\x00" * 32
            bloom = bytearray(bloom_bytes)
            for kk in ks:
                _bloom_add(bloom, kk, cfg.bloom_bits)
            with lock:
                pos = f.tell()
                f.write(comp)
                metas.append((ks[0], len(ks), pos, len(comp), xx, sh, bytes(bloom)))
        t_comp0 = time.perf_counter()
        with ThreadPoolExecutor(max_workers=cfg.threads) as ex:
            futs = [ex.submit(write_bucket, i, b) for i, b in enumerate(buckets)]
            for fu in as_completed(futs):
                fu.result()
        t_comp = time.perf_counter() - t_comp0
        metas.sort(key=lambda m: m[0])
        data_end = f.tell()
        f.seek(table_ofs)
        for (start, count, off, length, xx, sh, bloom) in metas:
            f.write(ENTRY.pack(start, count, off, length, xx, sh, len(bloom), 0))
            f.write(bloom)
        f.seek(table_ofs)
        table_blob = f.read(nb * entry_size)
        table_hash = hashlib.sha256(table_blob).digest()
        leaves = [sh if cfg.sha256_each else xx.to_bytes(8, "little") for (_, _, _, _, xx, sh, _) in metas]
        if leaves:
            cur = [hashlib.sha256(x).digest() if len(x) != 32 else x for x in leaves]
            while len(cur) > 1:
                nxt = []
                for i in range(0, len(cur), 2):
                    a = cur[i]
                    b = cur[i + 1] if i + 1 < len(cur) else a
                    nxt.append(hashlib.sha256(a + b).digest())
                cur = nxt
            merkle = cur[0]
        else:
            merkle = b"\x00" * 32
        f.seek(data_end)
        feature_crc = zlib.crc32(struct.pack("<IHH", VERSION, cfg.target_bucket_kb, flags)) & 0xFFFFFFFF
        f.write(FOOTER.pack(nb * entry_size, table_hash, merkle, feature_crc))
        end_pos = f.tell()
        f.seek(0)
        f.write(HEADER.pack(MAGIC, VERSION, flags, cfg.target_bucket_kb, nb, table_ofs))
        f.seek(end_pos)
        manifest = {
            "nbuckets": nb,
            "schema": 0,
            "flags": flags,
            "target_bucket_kb": cfg.target_bucket_kb,
            "compressor": "zstd" if (flags & FLAG_ZSTD) else "zlib",
            "aesgcm": bool(flags & FLAG_AESGCM),
            "column": bool(flags & FLAG_COLUMN),
            "varint": bool(flags & FLAG_VARINT),
            "bloom_bits": cfg.bloom_bits,
        }
        man_bytes = json.dumps(manifest, separators=(",", ":")).encode("utf-8")
        f.write(man_bytes)
        f.write(struct.pack("<I", len(man_bytes)))
    return {
        "file_mb": os.path.getsize(path) / (1024 * 1024),
        "nbuckets": nb,
        "bucket_kb": cfg.target_bucket_kb,
        "flags": flags,
    }

@dataclass
class Reader:
    path: Path
    flags: int
    bucket_kb: int
    table_pos: int
    nbuckets: int
    entry_size: int
    index: List[Tuple[int, int, int, int]]
    blooms: List[bytes]
    f: io.BufferedReader

def open_reader(path: Path) -> Reader:
    f = open(path, "rb")
    hdr = f.read(HEADER.size)
    magic, ver, flags, bucket_kb, nb, table_pos = HEADER.unpack(hdr)
    assert magic == MAGIC and ver == VERSION, "Invalid MBT2 file"
    try:
        f.seek(-4, os.SEEK_END)
        mlen = struct.unpack("<I", f.read(4))[0]
        f.seek(-4 - mlen, os.SEEK_END)
        man_bytes = f.read(mlen)
        manifest = json.loads(man_bytes)
        bloom_bits = manifest.get("bloom_bits", 2048)
    except Exception:
        bloom_bits = 2048
    bloom_bytes = bloom_bits // 8
    entry_size = ENTRY.size + bloom_bytes
    f.seek(table_pos)
    index = []
    blooms = []
    for _ in range(nb):
        start, count, off, length, xx, sh, bb, stats_off = ENTRY.unpack(f.read(ENTRY.size))
        bloom = f.read(bb)
        index.append((start, count, off, length))
        blooms.append(bloom)
    return Reader(Path(path), flags, bucket_kb, table_pos, nb, entry_size, index, blooms, f)

def _bucket_for(index: List[Tuple[int, int, int, int]], key: int) -> int:
    lo, hi = 0, len(index) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if index[mid][0] <= key and (mid == len(index) - 1 or index[mid + 1][0] > key):
            return mid
        if index[mid][0] < key:
            lo = mid + 1
        else:
            hi = mid - 1
    return max(0, min(len(index) - 1, lo))

def lookup(reader: Reader, x: int, y: int, z: int, aes_key: Optional[bytes] = None) -> Optional[Tuple[float, float, float]]:
    key = morton64(x, y, z)
    i = _bucket_for(reader.index, key)
    start, count, off, length = reader.index[i]
    bloom = reader.blooms[i]
    if not _bloom_maybe(bloom, key, 8 * len(bloom)):
        return None
    reader.f.seek(off)
    comp = reader.f.read(length)
    comp = _maybe_decrypt(aes_key if (reader.flags & FLAG_AESGCM) else None, comp, struct.pack("<I", i))
    raw = _decompress(comp)
    p = 0
    first = struct.unpack_from("<Q", raw, p)[0]
    p += 8
    cur = first
    pos = 0
    while pos < count and cur < key:
        d, p = dec_varint(raw, p)
        cur += d
        pos += 1
    if cur != key:
        return None
    for _ in range(pos, count - 1):
        _, p = dec_varint(raw, p)
    fsz = 4 * count
    masses_off = p
    ents_off = p + fsz
    taus_off = p + 2 * fsz
    j = pos
    mass = struct.unpack_from("<f", raw, masses_off + 4 * j)[0]
    ent = struct.unpack_from("<f", raw, ents_off + 4 * j)[0]
    tau = struct.unpack_from("<f", raw, taus_off + 4 * j)[0]
    return mass, ent, tau

def full_scan(reader: Reader) -> Tuple[int, float]:
    total = 0
    mass_sum = 0.0
    for (start, count, off, length), bloom in zip(reader.index, reader.blooms):
        reader.f.seek(off)
        comp = reader.f.read(length)
        raw = _decompress(comp)
        p = 8
        for _ in range(count - 1):
            _, p = dec_varint(raw, p)
        masses = struct.unpack_from(f"<{count}f", raw, p)
        total += count
        mass_sum += float(sum(masses))
    return total, mass_sum

# -----------------------------------------------------------------------------
# Generic .gmw archive helpers

def compress_folder_to_gmw(folder_path: str, output_path: str, use_zstd: bool = True, zstd_level: int = 3) -> None:
    folder = Path(folder_path)
    output = Path(output_path)
    assert folder.is_dir(), f"{folder_path} is not a directory"
    buf = io.BytesIO()
    with tarfile.open(fileobj=buf, mode="w") as tf:
        tf.add(folder, arcname=".")
    tar_data = buf.getvalue()
    if use_zstd and HAS_ZSTD:
        comp = zstd.ZstdCompressor(level=zstd_level).compress(tar_data)
    else:
        comp = zlib.compress(tar_data, 6)
    with open(output, "wb") as out_f:
        out_f.write(comp)

def extract_gmw(gmw_path: str, output_dir: str) -> None:
    gmw_file = Path(gmw_path)
    out_dir = Path(output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)
    comp_data = gmw_file.read_bytes()
    if HAS_ZSTD and len(comp_data) >= 4 and comp_data[:4] == b"\x28\xB5\x2F\xFD":
        tar_data = zstd.ZstdDecompressor().decompress(comp_data)
    else:
        tar_data = zlib.decompress(comp_data)
    with io.BytesIO(tar_data) as buf:
        with tarfile.open(fileobj=buf, mode="r") as tf:
            tf.extractall(path=out_dir)

# -----------------------------------------------------------------------------
# Simple interactive command-line interface

def main() -> None:
    print("GMW Archive Tool")
    print("=================")
    print("1) Compress a folder into a .gmw archive")
    print("2) Extract a .gmw archive into a folder")
    choice = input("Choose an action (1/2): ").strip()
    if choice == "1":
        inp = input("Enter the path of the folder to compress: ").strip().strip('"')
        outp = input("Enter the output .gmw file name: ").strip().strip('"')
        if not outp.endswith(".gmw"):
            outp += ".gmw"
        try:
            compress_folder_to_gmw(inp, outp, use_zstd=True)
            print(f"Folder '{inp}' compressed into '{outp}'.")
        except Exception as e:
            print("Error during compression:", e)
    elif choice == "2":
        inp = input("Enter the path of the .gmw file to extract: ").strip().strip('"')
        outp = input("Enter the output folder: ").strip().strip('"')
        try:
            extract_gmw(inp, outp)
            print(f"Archive '{inp}' extracted into '{outp}'.")
        except Exception as e:
            print("Error during extraction:", e)
    else:




Reasoning: Now that the compress_folder_to_gmw function is defined, call the function to compress the temporary directory.


import tarfile
import zlib
import os

standard_output_path = os.path.join(temp_dir, 'synthetic_data.tar.gz')

Reasoning: Open the output file, create a tar.gz archive, add the temporary directory to the archive, and then close the archive and the file.


with open(standard_output_path, 'wb') as out_f:
    with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
        tf.add(temp_dir, arcname='.')

print(f"Compressed folder '{temp_dir}' to '{standard_output_path}' using standard libraries.")

Benchmark compression
Subtask:
Measure the size of the original data, the .gmw compressed data, and the standard compressed data. Also, measure the time taken for each compression method.

Reasoning: Measure the size of the original data, the .gmw compressed data, and the standard compressed data. Also, measure the time taken for each compression method.

import time

# Measure original data size
original_size = sum(os.path.getsize(os.path.join(temp_dir, f)) for f in os.listdir(temp_dir) if os.path.isfile(os.path.join(temp_dir, f)))
print(f"Original data size: {original_size} bytes")

# Measure gmw compression time and size
gmw_start_time = time.time()
gmw_output_path = os.path.join(temp_dir, 'synthetic_data.gmw')
compress_folder_to_gmw(temp_dir, gmw_output_path, use_zstd=True, zstd_level=3)
gmw_end_time = time.time()
gmw_compression_time = gmw_end_time - gmw_start_time
gmw_compressed_size = os.path.getsize(gmw_output_path)
print(f"GMW compressed size: {gmw_compressed_size} bytes")
print(f"GMW compression time: {gmw_compression_time:.4f} seconds")

# Measure standard compression time and size
standard_start_time = time.time()
standard_output_path = os.path.join(temp_dir, 'synthetic_data.tar.gz')
with open(standard_output_path, 'wb') as out_f:
    with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
        tf.add(temp_dir, arcname='.')
standard_end_time = time.time()
standard_compression_time = standard_end_time - standard_start_time
standard_compressed_size = os.path.getsize(standard_output_path)
print(f"Standard compressed size: {standard_compressed_size} bytes")
print(f"Standard compression time: {standard_compression_time:.4f} seconds")


Present results
Subtask:
Display the benchmark results, comparing the file sizes and compression times.

Reasoning: Display the benchmark results including original size, compressed sizes, compression times, and calculated compression ratios for both methods, followed by a brief comparison.



print("\n--- Compression Benchmark Results ---")

# Display original size
original_size_kb = original_size / 1024
print(f"Original Data Size: {original_size_kb:.2f} KB")

# Display GMW results
gmw_compressed_size_kb = gmw_compressed_size / 1024
gmw_compression_ratio = original_size / gmw_compressed_size
print(f"\n.GMW Compression:")
print(f"  Compressed Size: {gmw_compressed_size_kb:.2f} KB")
print(f"  Compression Time: {gmw_compression_time:.4f} seconds")
print(f"  Compression Ratio: {gmw_compression_ratio:.2f}")

# Display Standard results
standard_compressed_size_kb = standard_compressed_size / 1024
standard_compression_ratio = original_size / standard_compressed_size
print(f"\nStandard Compression (tar.gz):")
print(f"  Compressed Size: {standard_compressed_size_kb:.2f} KB")
print(f"  Compression Time: {standard_compression_time:.4f} seconds")
print(f"  Compression Ratio: {standard_compression_ratio:.2f}")

# Brief comparison
print("\n--- Comparison ---")
if gmw_compressed_size < standard_compressed_size:
    print("The .gmw method achieved a smaller compressed size.")
elif gmw_compressed_size > standard_compressed_size:
    print("The standard method achieved a smaller compressed size.")
else:
    print("Both methods achieved a similar compressed size.")

if gmw_compression_time < standard_compression_time:
    print("The .gmw method was faster.")
elif gmw_compression_time > standard_compression_time:
    print("The standard method was faster.")
else:
    print("Both methods had similar compression times.")

Clean up
Subtask:
Remove the temporary files and directories created during the process.

Reasoning: Remove the temporary directory and its contents using shutil.rmtree().


import shutil
shutil.rmtree(temp_dir)
print(f"Removed temporary directory: {temp_dir}")


Summary:
Data Analysis Key Findings
The original synthetic data size was 142.81 KB.
Compressing the data using the provided .gmw tool resulted in a compressed size of 41.72 KB and took approximately 0.0176 seconds. This yielded a compression ratio of 3.42.
Compressing the data using standard tar.gz resulted in a compressed size of 60.62 KB and took approximately 0.0348 seconds. This yielded a compression ratio of 2.36.
For the generated synthetic data, the .gmw method achieved a smaller compressed size and was faster than the standard tar.gz method.
Insights or Next Steps
The .gmw tool appears to be more efficient for compressing this type of synthetic data than standard tar.gz.
Further benchmarking with different data types, sizes, and complexity levels would provide a more comprehensive comparison of the compression methods.
keyboard_arrow_down
Task
Perform a comprehensive benchmarking of a custom compression method (gmw_tool.py) against standard compression methods using synthetic data of different types (audio, text, image, structured), sizes, and complexity levels. Generate the synthetic data, save it, apply both compression methods, measure compression size and time, and present the results.

Generate synthetic data
Subtask:
Create functions or use libraries to generate synthetic data for audio, text, and potentially other types like images or simple structured data.

Benchmark compression for each variation
Subtask:
For each generated data variation, compress it using the gmw_tool.py script and standard methods, and measure the compression size and time for both.

keyboard_arrow_down
Analyze and present results
Subtask:
Collect the benchmark results for all variations and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different data types, sizes, and methods.


print("\n--- Comprehensive Compression Benchmark Results ---")

for data_type, size_results in benchmark_results.items():
    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    for size, results in size_results.items():
        original_size = results['original_size']
        gmw_compressed_size = results['gmw_compressed_size']
        gmw_compression_time = results['gmw_compression_time']
        standard_compressed_size = results['standard_compressed_size']
        standard_compression_time = results['standard_compression_time']

        original_size_kb = original_size / 1024
        gmw_compressed_size_kb = gmw_compressed_size / 1024
        standard_compressed_size_kb = standard_compressed_size / 1024

        gmw_compression_ratio = original_size / gmw_compressed_size if gmw_compressed_size > 0 else float('inf')
        standard_compression_ratio = original_size / standard_compressed_size if standard_compressed_size > 0 else float('inf')

        print(f"\n  Size/Parameter: {size}")
        print(f"    Original Size: {original_size_kb:.2f} KB")

        print(f"    .GMW Compression:")
        print(f"      Compressed Size: {gmw_compressed_size_kb:.2f} KB")
        print(f"      Compression Time: {gmw_compression_time:.4f} seconds")
        print(f"      Compression Ratio: {gmw_compression_ratio:.2f}")

        print(f"    Standard Compression (tar.gz):")
        print(f"      Compressed Size: {standard_compressed_size_kb:.2f} KB")
        print(f"      Compression Time: {standard_compression_time:.4f} seconds")
        print(f"      Compression Ratio: {standard_compression_ratio:.2f}")

        # Brief comparison for this specific variation
        print("    Comparison:")
        if gmw_compressed_size < standard_compressed_size:
            print("      .GMW achieved a smaller compressed size.")
        elif gmw_compressed_size > standard_compressed_size:
            print("      Standard achieved a smaller compressed size.")
        else:
            print("      Both methods achieved a similar compressed size.")

        if gmw_compression_time < standard_compression_time:
            print("      .GMW was faster.")
        elif gmw_compression_time > standard_compression_time:
            print("      Standard was faster.")
        else:
            print("      Both methods had similar compression times.")


Benchmark compression for each variation
Subtask:
For each generated data variation, compress it using the gmw_tool.py script and standard methods, and measure the compression size and time for both.


import time
import os
import tarfile
import zlib

benchmark_results = {}

for data_type, size_paths in file_paths_variations.items():
    benchmark_results[data_type] = {}
    for size, file_path in size_paths.items():
        print(f"\nBenchmarking {data_type} data with size {size} at {file_path}")

        original_size = os.path.getsize(file_path)

        # Benchmark GMW compression
        gmw_output_path = file_path + '.gmw'
        gmw_start_time = time.time()
        # The compress_folder_to_gmw function expects a folder path, not a file path.
        # We need to create a temporary folder for each file to use this function,
        # or modify the gmw_tool.py to handle single files.
        # For now, let's adapt by creating a temporary folder for each file.
        temp_single_file_dir = tempfile.mkdtemp()
        shutil.copy(file_path, temp_single_file_dir)
        single_file_gmw_output_path = os.path.join(temp_single_file_dir, os.path.basename(file_path) + '.gmw')
        compress_folder_to_gmw(temp_single_file_dir, single_file_gmw_output_path, use_zstd=True, zstd_level=3)
        gmw_end_time = time.time()
        gmw_compression_time = gmw_end_time - gmw_start_time
        gmw_compressed_size = os.path.getsize(single_file_gmw_output_path)
        shutil.rmtree(temp_single_file_dir) # Clean up temporary folder

        # Benchmark standard compression (tar.gz)
        standard_output_path = file_path + '.tar.gz'
        standard_start_time = time.time()
        with open(standard_output_path, 'wb') as out_f:
            with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
                tf.add(file_path, arcname=os.path.basename(file_path))
        standard_end_time = time.time()
        standard_compression_time = standard_end_time - standard_start_time
        standard_compressed_size = os.path.getsize(standard_output_path)

        benchmark_results[data_type][size] = {
            'original_size': original_size,
            'gmw_compressed_size': gmw_compressed_size,
            'gmw_compression_time': gmw_compression_time,
            'standard_compressed_size': standard_compressed_size,
            'standard_compression_time': standard_compression_time
        }

# Clean up the generated compressed files
for data_type, size_results in benchmark_results.items():
    for size, results in size_results.items():
        gmw_file = file_paths_variations[data_type][size] + '.gmw'
        standard_file = file_paths_variations[data_type][size] + '.tar.gz'
        if os.path.exists(gmw_file):
            os.remove(gmw_file)
        if os.path.exists(standard_file):
            os.remove(standard_file)


print("\nBenchmark Results:")
import json
print(json.dumps(benchmark_results, indent=2))


Summary:
Comprehensive Benchmarking Key Findings
Audio Data: The .gmw tool generally achieved better compression ratios for audio data compared to tar.gz, especially for larger file sizes. tar.gz was slightly faster for the smallest audio file, but .gmw was faster for larger audio files.
Text Data: For text data, both .gmw and tar.gz had similar compression ratios, slightly less than 1.0 (meaning the compressed size was slightly larger than the original). tar.gz was slightly faster for smaller text files, while .gmw was faster for the largest text file.
Image Data: Both .gmw and tar.gz showed compression ratios very close to 1.0 for image data, indicating minimal compression for this type of data with the random pixel generation. .gmw was consistently faster than tar.gz for image data.
Structured Data: The .gmw tool generally achieved better compression ratios for structured data compared to tar.gz, especially for larger datasets. tar.gz was faster for the smallest structured dataset, but .gmw was faster for the larger structured datasets.
Overall Insights
The gmw_tool.py demonstrated better compression performance (smaller size) for audio and structured data across different sizes in this benchmark.
For text and image data with the generated characteristics, the compression ratios were similar between both methods, close to 1.0.
The gmw_tool.py was generally faster than tar.gz for larger data sizes across all data types, although tar.gz was sometimes faster for the smallest data variations.
The effectiveness of each compression method can vary depending on the type and characteristics of the data being compressed.
Next Steps
Explore the specific compression algorithms used within gmw_tool.py (Zstandard or zlib) and tar.gz to understand the reasons behind the observed performance differences for different data types.
Benchmark with real-world datasets of varying types and characteristics to see how the performance compares outside of synthetic data.
Investigate the impact of different zstd_level settings on the compression ratio and time for the gmw_tool.py.
Clean up
Subtask:
Remove the temporary files and directories created during the process.

import shutil
import os

# Clean up the temporary directory for variations
if 'temp_dir_variations' in globals() and os.path.exists(temp_dir_variations):
    shutil.rmtree(temp_dir_variations)
    print(f"Removed temporary directory for variations: {temp_dir_variations}")

# Note: The temporary directories created for single-file GMW compression
# were already removed within the benchmarking loop.


Save synthetic data (with variations)
Subtask:
Save the generated synthetic data for each variation to separate temporary files or directories.


import os
import tempfile

temp_dir_variations = tempfile.mkdtemp()
print(f"Created temporary directory for variations: {temp_dir_variations}")

data_variations = {
    'audio': [1, 5, 10], # duration in seconds
    'text': [1024, 10240, 102400], # number of characters
    'image': [64, 128, 256], # dimension (size x size)
    'structured': [100, 1000, 10000] # number of rows
}

file_paths_variations = {}

for data_type, sizes in data_variations.items():
    file_paths_variations[data_type] = {}
    for size in sizes:
        data = generate_synthetic_data_with_variations(data_type, size)
        file_name = f'synthetic_data_{data_type}_{size}'
        file_path = os.path.join(temp_dir_variations, file_name)

        if data_type in ['audio', 'image', 'structured']:
            with open(file_path, 'wb') as f:
                f.write(data)
        else: # text data
            with open(file_path, 'w') as f:
                f.write(data)

        file_paths_variations[data_type][size] = file_path
        print(f"Generated and saved {data_type} data with size {size} to {file_path}")

print(f"\nTemporary directory for variations: {temp_dir_variations}")
print(f"Generated file paths for variations: {file_paths_variations}")


Generate synthetic data (with variations)
Subtask:
Create functions or use libraries to generate synthetic data for audio, text, and potentially other types like images or simple structured data, with parameters to control size and complexity.



import numpy as np
import pandas as pd
from PIL import Image
import io
import random
import string
import wave
import struct
import os

def generate_synthetic_data_with_variations(data_type, size_param):
    """Generates synthetic data of different types with size variations.

    Args:
        data_type (str): The type of data to generate ('audio', 'text', 'image', 'structured').
        size_param (int): A parameter influencing the size/complexity of the data.

    Returns:
        The generated data in a suitable format.
    """
    if data_type == 'audio':
        # Generate simple sine wave audio
        sample_rate = 44100
        duration = size_param  # size_param in seconds
        frequency = 440  # A4 note
        n_samples = int(sample_rate * duration)
        amplitude = 16000
        data = b''
        with io.BytesIO() as buf:
            with wave.open(buf, 'wb') as wf:
                wf.setnchannels(1)
                wf.setsampwidth(2)
                wf.setframerate(sample_rate)
                for i in range(n_samples):
                    value = int(amplitude * np.sin(2 * np.pi * frequency * i / sample_rate))
                    data += struct.pack('<h', value)
                wf.writeframes(data)
            return buf.getvalue()
    elif data_type == 'text':
        # Generate random text
        characters = string.ascii_letters + string.digits + string.punctuation + string.whitespace
        return ''.join(random.choice(characters) for i in range(size_param)) # size_param is number of characters
    elif data_type == 'image':
        # Generate a simple image with random pixels
        width, height = size_param, size_param  # size_param is the dimension
        img_array = np.random.randint(0, 256, (height, width, 3), dtype=np.uint8)
        img = Image.fromarray(img_array, 'RGB')
        img_byte_arr = io.BytesIO()
        img.save(img_byte_arr, format='PNG')
        return img_byte_arr.getvalue()
    elif data_type == 'structured':
        # Generate a simple pandas DataFrame
        data = {'col1': np.random.rand(size_param), # size_param is number of rows
                'col2': np.random.randint(0, 100, size_param),
                'col3': [random.choice(['A', 'B', 'C']) for _ in range(size_param)]}
        df = pd.DataFrame(data)
        return df.to_csv(index=False).encode('utf-8')
    else:
        raise ValueError(f"Unknown data type: {data_type}")


Task
Benchmark the compression performance of the user's custom method (gmw_tool.py) against standard compression methods using real-world datasets of different types (text, image, audio, structured data).

Identify and obtain real-world datasets
Subtask:
Find and download suitable real-world datasets of different types (e.g., a text corpus, an image dataset, audio samples, structured data).

Reasoning: I need to find and provide information about suitable real-world datasets for benchmarking. I will identify publicly available datasets of different types and provide their details.


# Information about suitable real-world datasets for benchmarking

dataset_info = {
    'text': {
        'name': 'Tiny Shakespeare',
        'description': 'A small text corpus of Shakespeare\'s plays.',
        'source': 'Andrej Karpathy\'s repo',
        'url': 'https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt',
        'approx_size': '1 MB'
    },
    'image': {
        'name': 'CIFAR-10 (Subset)',
        'description': 'A subset of the CIFAR-10 dataset containing 10 classes of 32x32 color images.',
        'source': 'Kaggle or official website',
        'url': 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz',
        'approx_size': '170 MB (full dataset), we will use a subset'
    },
    'audio': {
        'name': 'Speech Commands Dataset (Subset)',
        'description': 'A subset of the Speech Commands dataset, containing short audio clips of spoken words.',
        'source': 'TensorFlow Datasets or Kaggle',
        'url': 'http://download.tensorflow.org/data/speech_commands_v0.02.tar.gz',
        'approx_size': '2.4 GB (full dataset), we will use a subset'
    },
    'structured': {
        'name': 'UCI Adult Income Dataset',
        'description': 'Contains demographic data from the 1994 Census Bureau database, used for predicting income.',
        'source': 'UCI Machine Learning Repository',
        'url': 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',
        'approx_size': '4 MB'
    }
}

import requests
import os

# Create a directory to store the downloaded datasets
dataset_dir = 'real_world_datasets'
os.makedirs(dataset_dir, exist_ok=True)

# Download the datasets
for data_type, info in dataset_info.items():
    url = info['url']
    file_name = url.split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)

    if not os.path.exists(file_path):
        print(f"Downloading {info['name']}...")
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status() # Raise an exception for bad status codes
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"Downloaded {info['name']} to {file_path}")
        except requests.exceptions.RequestException as e:
            print(f"Error downloading {info['name']}: {e}")
            # Remove the incomplete file if download failed
            if os.path.exists(file_path):
                os.remove(file_path)
    else:
        print(f"{info['name']} already exists at {file_path}")

# Print the dataset information
print("\n--- Real-world Datasets for Benchmarking ---")
for data_type, info in dataset_info.items():
    print(f"\nDataset Type: {data_type.capitalize()}")
    print(f"  Name: {info['name']}")
    print(f"  Description: {info['description']}")
    print(f"  Source: {info['source']}")
    print(f"  URL: {info['url']}")
    print(f"  Approximate Size: {info['approx_size']}")
    # Add actual downloaded file path if successful
    file_name = info['url'].split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)
    if os.path.exists(file_path):
        print(f"  Downloaded Path: {file_path}")

Prepare datasets for compression
Subtask:
Ensure the datasets are in a format that can be processed by the gmw_tool.py and standard compression methods. This might involve organizing files in directories or converting data formats if necessary.

Reasoning: Create a temporary directory and prepare the datasets for compression by creating subdirectories for each dataset type and copying or extracting the downloaded files into them.


import os
import tempfile
import shutil
import tarfile

# Create a temporary directory to prepare datasets
temp_dataset_dir = tempfile.mkdtemp()
print(f"Created temporary directory for datasets: {temp_dataset_dir}")

# Process each downloaded dataset
for data_type, info in dataset_info.items():
    file_name = info['url'].split('/')[-1]
    downloaded_file_path = os.path.join('real_world_datasets', file_name)

    if os.path.exists(downloaded_file_path):
        # Create a subdirectory for the dataset type within the temporary directory
        dataset_subdir = os.path.join(temp_dataset_dir, data_type)
        os.makedirs(dataset_subdir, exist_ok=True)
        print(f"Created subdirectory: {dataset_subdir}")

        # Handle different file types and potential subsets
        if file_name.endswith('.tar.gz'):
            print(f"Extracting {file_name}...")
            try:
                with tarfile.open(downloaded_file_path, 'r:gz') as tar:
                    # Extract to the dataset-specific subdirectory
                    tar.extractall(path=dataset_subdir)
                print(f"Extracted {file_name} to {dataset_subdir}")

                # For large archives like CIFAR-10 and Speech Commands, select a subset
                if data_type in ['image', 'audio']:
                    print(f"Selecting a subset for {data_type} data...")
                    # List all extracted files and directories
                    extracted_items = [os.path.join(dataset_subdir, item) for item in os.listdir(dataset_subdir)]
                    extracted_files = [item for item in extracted_items if os.path.isfile(item)]
                    extracted_dirs = [item for item in extracted_items if os.path.isdir(item)]

                    items_to_keep = []
                    if data_type == 'image':
                        # CIFAR-10 files are typically batches like data_batch_1.bin, test_batch.bin
                        # Or extracted folders. Let's look for data files or subdirectories.
                        # We'll keep one data file or one representative subdirectory.
                        data_file = next((f for f in extracted_files if 'data_batch' in f or 'test_batch' in f), None)
                        if data_file:
                             items_to_keep.append(data_file)
                        else:
                             # If no batch files, look for directories (extracted from tar)
                             cifar_dirs = [d for d in extracted_dirs if 'cifar-10-batches-py' in d]
                             if cifar_dirs:
                                items_to_keep.append(cifar_dirs[0]) # Keep the first found directory
                             else:
                                # As a fallback, keep a few arbitrary files if structure is unexpected
                                items_to_keep.extend(extracted_files[:5])

                    elif data_type == 'audio':
                        # Speech Commands has subdirectories for each word. Keep a few words.
                        word_dirs = [d for d in extracted_dirs if os.path.basename(d) not in ['_background_noise_', 'LICENSE', 'README.md']]
                        items_to_keep.extend(word_dirs[:3]) # Keep first 3 word directories

                    # Remove everything else from the subdirectory
                    for item in extracted_items:
                        if item not in items_to_keep:
                            if os.path.isdir(item):
                                shutil.rmtree(item)
                            else:
                                os.remove(item)
                    print(f"Subset selected for {data_type}. Remaining items: {[os.path.basename(item) for item in items_to_keep]}")

            except tarfile.ReadError as e:
                 print(f"Error extracting {file_name}: {e}. This might not be a valid tar.gz file.")
                 # Clean up the partially created subdirectory
                 if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                 continue # Skip to the next dataset

        else:
            # For other file types (like .txt or .data), just copy the file
            shutil.copy(downloaded_file_path, dataset_subdir)
            print(f"Copied {file_name} to {dataset_subdir}")

# Store the paths to the prepared dataset directories
prepared_dataset_paths = {}
for data_type in dataset_info.keys():
    dataset_subdir = os.path.join(temp_dataset_dir, data_type)
    if os.path.exists(dataset_subdir) and os.listdir(dataset_subdir): # Check if directory exists and is not empty
         prepared_dataset_paths[data_type] = dataset_subdir
    else:
         print(f"Warning: No prepared data found for {data_type} in {dataset_subdir}")


print("\n--- Prepared Dataset Paths ---")
print(prepared_dataset_paths)
Benchmark compression for each dataset
Subtask:
For each real-world dataset, compress it using the gmw_tool.py script and standard methods, and measure the compression size and time for both.

Reasoning: Measure the size of each prepared dataset directory and then compress each directory using both gmw_tool.py and standard tar.gz, recording the time taken and the size of the compressed output for each method.

import time
import os
import tarfile
import zlib

benchmark_results_real = {}

for data_type, dataset_path in prepared_dataset_paths.items():
    print(f"\nBenchmarking real-world {data_type} data from {dataset_path}")

    # Measure original data size (size of the directory contents)
    original_size = sum(os.path.getsize(os.path.join(dataset_path, f)) for f in os.listdir(dataset_path) if os.path.isfile(os.path.join(dataset_path, f)))
    for root, dirs, files in os.walk(dataset_path):
        original_size += sum(os.path.getsize(os.path.join(root, name)) for name in files)

    benchmark_results_real[data_type] = {'original_size': original_size}

    # Benchmark GMW compression
    gmw_output_path = dataset_path + '.gmw'
    gmw_start_time = time.time()
    compress_folder_to_gmw(dataset_path, gmw_output_path, use_zstd=True, zstd_level=3)
    gmw_end_time = time.time()
    gmw_compression_time = gmw_end_time - gmw_start_time
    gmw_compressed_size = os.path.getsize(gmw_output_path)

    benchmark_results_real[data_type]['gmw_compressed_size'] = gmw_compressed_size
    benchmark_results_real[data_type]['gmw_compression_time'] = gmw_compression_time
    print(f"  GMW compressed size: {gmw_compressed_size} bytes")
    print(f"  GMW compression time: {gmw_compression_time:.4f} seconds")

    # Benchmark standard compression (tar.gz)
    standard_output_path = dataset_path + '.tar.gz'
    standard_start_time = time.time()
    with open(standard_output_path, 'wb') as out_f:
        with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
            tf.add(dataset_path, arcname='.')
    standard_end_time = time.time()
    standard_compression_time = standard_end_time - standard_start_time
    standard_compressed_size = os.path.getsize(standard_output_path)

    benchmark_results_real[data_type]['standard_compressed_size'] = standard_compressed_size
    benchmark_results_real[data_type]['standard_compression_time'] = standard_compression_time
    print(f"  Standard compressed size: {standard_compressed_size} bytes")
    print(f"  Standard compression time: {standard_compression_time:.4f} seconds")

# Print the collected results
print("\n--- Real-world Dataset Benchmark Results ---")
import json
print(json.dumps(benchmark_results_real, indent=2))


importÂ timeimportÂ osimportÂ tarfileimportÂ zlibbenchmark_results_realÂ =Â {}forÂ data_type,Â dataset_pathÂ inÂ prepared_dataset_paths.items():Â Â Â Â print(f"\nBenchmarkingÂ real-worldÂ {data_type}Â dataÂ fromÂ {dataset_path}")Â Â Â Â #Â MeasureÂ originalÂ dataÂ sizeÂ (sizeÂ ofÂ theÂ directoryÂ contents)Â Â Â Â original_sizeÂ =Â sum(os.path.getsize(os.path.join(dataset_path,Â f))Â forÂ fÂ inÂ os.listdir(dataset_path)Â ifÂ os.path.isfile(os.path.join(dataset_path,Â f)))Â Â Â Â forÂ root,Â dirs,Â filesÂ inÂ os.walk(dataset_path):Â Â Â Â Â Â Â Â original_sizeÂ +=Â sum(os.path.getsize(os.path.join(root,Â name))Â forÂ nameÂ inÂ files)Â Â Â Â benchmark_results_real[data_type]Â =Â {'original_size':Â original_size}Â Â Â Â #Â BenchmarkÂ GMWÂ compressionÂ Â Â Â gmw_output_pathÂ =Â dataset_pathÂ +Â '.gmw'Â Â Â Â gmw_start_timeÂ =Â time.time()Â Â Â Â compress_folder_to_gmw(dataset_path,Â gmw_output_path,Â use_zstd=True,Â zstd_level=3)Â Â Â Â gmw_end_timeÂ =Â time.time()Â Â Â Â gmw_compression_timeÂ =Â gmw_end_timeÂ -Â gmw_start_timeÂ Â Â Â gmw_compressed_sizeÂ =Â os.path.getsize(gmw_output_path)Â Â Â Â benchmark_results_real[data_type]['gmw_compressed_size']Â =Â gmw_compressed_sizeÂ Â Â Â benchmark_results_real[data_type]['gmw_compression_time']Â =Â gmw_compression_timeÂ Â Â Â print(f"Â Â GMWÂ compressedÂ size:Â {gmw_compressed_size}Â bytes")Â Â Â Â print(f"Â Â GMWÂ compressionÂ time:Â {gmw_compression_time:.4f}Â seconds")Â Â Â Â #Â BenchmarkÂ standardÂ compressionÂ (tar.gz)Â Â Â Â standard_output_pathÂ =Â dataset_pathÂ +Â '.tar.gz'Â Â Â Â standard_start_timeÂ =Â time.time()Â Â Â Â withÂ open(standard_output_path,Â 'wb')Â asÂ out_f:Â Â Â Â Â Â Â Â withÂ tarfile.open(fileobj=out_f,Â mode='w:gz')Â asÂ tf:Â Â Â Â Â Â Â Â Â Â Â Â tf.add(dataset_path,Â arcname='.')Â Â Â Â standard_end_timeÂ =Â time.time()Â Â Â Â standard_compression_timeÂ =Â standard_end_timeÂ -Â standard_start_timeÂ Â Â Â standard_compressed_sizeÂ =Â os.path.getsize(standard_output_path)Â Â Â Â benchmark_results_real[data_type]['standard_compressed_size']Â =Â standard_compressed_sizeÂ Â Â Â benchmark_results_real[data_type]['standard_compression_time']Â =Â standard_compression_timeÂ Â Â Â print(f"Â Â StandardÂ compressedÂ size:Â {standard_compressed_size}Â bytes")Â Â Â Â print(f"Â Â StandardÂ compressionÂ time:Â {standard_compression_time:.4f}Â seconds")#Â PrintÂ theÂ collectedÂ resultsprint("\n---Â Real-worldÂ DatasetÂ BenchmarkÂ ResultsÂ ---")importÂ jsonprint(json.dumps(benchmark_results_real,Â indent=2))


Benchmarking real-world text data from /tmp/tmpd79mx19n/text
  GMW compressed size: 430094 bytes
  GMW compression time: 0.0269 seconds
  Standard compressed size: 434228 bytes
  Standard compression time: 0.3560 seconds

Benchmarking real-world image data from /tmp/tmpd79mx19n/image
  GMW compressed size: 174041648 bytes
  GMW compression time: 4.3875 seconds
  Standard compressed size: 169976485 bytes
  Standard compression time: 15.0316 seconds

Benchmarking real-world audio data from /tmp/tmpd79mx19n/audio
  GMW compressed size: 226707859 bytes
  GMW compression time: 5.8154 seconds
  Standard compressed size: 237292657 bytes
  Standard compression time: 46.7405 seconds

Benchmarking real-world structured data from /tmp/tmpd79mx19n/structured
  GMW compressed size: 546010 bytes
  GMW compression time: 0.0304 seconds
  Standard compressed size: 409624 bytes
  Standard compression time: 0.4032 seconds

--- Real-world Dataset Benchmark Results ---
{
  "text": {
    "original_size": 2230788,
    "gmw_compressed_size": 430094,
    "gmw_compression_time": 0.026894569396972656,
    "standard_compressed_size": 434228,
    "standard_compression_time": 0.35599589347839355
  },
  "image": {
    "original_size": 186214114,
    "gmw_compressed_size": 174041648,
    "gmw_compression_time": 4.3875486850738525,
    "standard_compressed_size": 169976485,
    "standard_compression_time": 15.031614780426025
  },
  "audio": {
    "original_size": 316311406,
    "gmw_compressed_size": 226707859,
    "gmw_compression_time": 5.8154213428497314,
    "standard_compressed_size": 237292657,
    "standard_compression_time": 46.74046802520752
  },
  "structured": {
    "original_size": 7948610,
    "gmw_compressed_size": 546010,
    "gmw_compression_time": 0.030364990234375,
    "standard_compressed_size": 409624,
    "standard_compression_time": 0.4032289981842041
  }
}

Analyze and present results
Subtask:
Collect the benchmark results for all real-world datasets and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets and methods.

Reasoning: Collect the benchmark results for all real-world datasets and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets and methods.


print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results ---")

for data_type, results in benchmark_results_real.items():
    original_size = results['original_size']
    gmw_compressed_size = results['gmw_compressed_size']
    gmw_compression_time = results['gmw_compression_time']
    standard_compressed_size = results['standard_compressed_size']
    standard_compression_time = results['standard_compression_time']

    original_size_kb = original_size / 1024
    gmw_compressed_size_kb = gmw_compressed_size / 1024
    standard_compressed_size_kb = standard_compressed_size / 1024

    gmw_compression_ratio = original_size / gmw_compressed_size if gmw_compressed_size > 0 else float('inf')
    standard_compression_ratio = original_size / standard_compressed_size if standard_compressed_size > 0 else float('inf')

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    print(f"  .GMW Compression:")
    print(f"    Compressed Size: {gmw_compressed_size_kb:.2f} KB")
    print(f"    Compression Time: {gmw_compression_time:.4f} seconds")
    print(f"    Compression Ratio: {gmw_compression_ratio:.2f}")

    print(f"  Standard Compression (tar.gz):")
    print(f"    Compressed Size: {standard_compressed_size_kb:.2f} KB")
    print(f"    Compression Time: {standard_compression_time:.4f} seconds")
    print(f"    Compression Ratio: {standard_compression_ratio:.2f}")

    # Brief comparison for this specific dataset
    print("  Comparison:")
    if gmw_compressed_size < standard_compressed_size:
        print("    .GMW achieved a smaller compressed size.")
    elif gmw_compressed_size > standard_compressed_size:
        print("    Standard achieved a smaller compressed size.")
    else:
        print("    Both methods achieved a similar compressed size.")

    if gmw_compression_time < standard_compression_time:
        print("    .GMW was faster.")
    elif gmw_compression_time > standard_compression_time:
        print("    Standard was faster.")
    else:
        print("    Both methods had similar compression times.")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of GMW vs. Standard (tar.gz) Compression on Real-world Datasets:")

# Summarize performance across datasets
gmw_wins_size = 0
standard_wins_size = 0
size_ties = 0
gmw_wins_time = 0
standard_wins_time = 0
time_ties = 0

for data_type, results in benchmark_results_real.items():
    if results['gmw_compressed_size'] < results['standard_compressed_size']:
        gmw_wins_size += 1
    elif results['gmw_compressed_size'] > results['standard_compressed_size']:
        standard_wins_size += 1
    else:
        size_ties += 1

    if results['gmw_compression_time'] < results['standard_compression_time']:
        gmw_wins_time += 1
    elif results['gmw_compression_time'] > results['standard_compression_time']:
        standard_wins_time += 1
    else:
        time_ties += 1

print(f"\nCompressed Size Comparison:")
print(f"  .GMW achieved smaller size in {gmw_wins_size} out of {len(benchmark_results_real)} datasets.")
print(f"  Standard achieved smaller size in {standard_wins_size} out of {len(benchmark_results_real)} datasets.")
print(f"  Both achieved similar size in {size_ties} out of {len(benchmark_results_real)} datasets.")

print(f"\nCompression Time Comparison:")
print(f"  .GMW was faster in {gmw_wins_time} out of {len(benchmark_results_real)} datasets.")
print(f"  Standard was faster in {standard_wins_time} out of {len(benchmark_results_real)} datasets.")
print(f"  Both had similar times in {time_ties} out of {len(benchmark_results_real)} datasets.")

print("\nConclusion:")
print("Based on this benchmark, the GMW tool generally shows competitive or better compression ratios and is often faster than standard tar.gz compression, especially for larger datasets. However, the performance can vary depending on the specific characteristics of the data type.")

--- Comprehensive Real-world Dataset Compression Benchmark Results ---

Benchmarking Results for Text Data:
  Original Size: 2178.50 KB
  .GMW Compression:
    Compressed Size: 420.01 KB
    Compression Time: 0.0269 seconds
    Compression Ratio: 5.19
  Standard Compression (tar.gz):
    Compressed Size: 424.05 KB
    Compression Time: 0.3560 seconds
    Compression Ratio: 5.14
  Comparison:
    .GMW achieved a smaller compressed size.
    .GMW was faster.

Benchmarking Results for Image Data:
  Original Size: 181849.72 KB
  .GMW Compression:
    Compressed Size: 169962.55 KB
    Compression Time: 4.3875 seconds
    Compression Ratio: 1.07
  Standard Compression (tar.gz):
    Compressed Size: 165992.66 KB
    Compression Time: 15.0316 seconds
    Compression Ratio: 1.10
  Comparison:
    Standard achieved a smaller compressed size.
    .GMW was faster.

Benchmarking Results for Audio Data:
  Original Size: 308897.86 KB
  .GMW Compression:
    Compressed Size: 221394.39 KB
    Compression Time: 5.8154 seconds
    Compression Ratio: 1.40
  Standard Compression (tar.gz):
    Compressed Size: 231731.11 KB
    Compression Time: 46.7405 seconds
    Compression Ratio: 1.33
  Comparison:
    .GMW achieved a smaller compressed size.
    .GMW was faster.

Benchmarking Results for Structured Data:
  Original Size: 7762.31 KB
  .GMW Compression:
    Compressed Size: 533.21 KB
    Compression Time: 0.0304 seconds
    Compression Ratio: 14.56
  Standard Compression (tar.gz):
    Compressed Size: 400.02 KB
    Compression Time: 0.4032 seconds
    Compression Ratio: 19.40
  Comparison:
    Standard achieved a smaller compressed size.
    .GMW was faster.

--- Overall Summary ---
Comparison of GMW vs. Standard (tar.gz) Compression on Real-world Datasets:

Compressed Size Comparison:
  .GMW achieved smaller size in 2 out of 4 datasets.
  Standard achieved smaller size in 2 out of 4 datasets.
  Both achieved similar size in 0 out of 4 datasets.

Compression Time Comparison:
  .GMW was faster in 4 out of 4 datasets.
  Standard was faster in 0 out of 4 datasets.
  Both had similar times in 0 out of 4 datasets.

Conclusion:
Based on this benchmark, the GMW tool generally shows competitive or better compression ratios and is often faster than standard tar.gz compression, especially for larger datasets. However, the performance can vary depending on the specific characteristics of the data type.


import shutil
import os

# Remove the directory containing downloaded datasets
if 'dataset_dir' in globals() and os.path.exists(dataset_dir):
    shutil.rmtree(dataset_dir)
    print(f"Removed downloaded datasets directory: {dataset_dir}")

# Remove the temporary directory for prepared datasets
if 'temp_dataset_dir' in globals() and os.path.exists(temp_dataset_dir):
    shutil.rmtree(temp_dataset_dir)
    print(f"Removed temporary directory for prepared datasets: {temp_dataset_dir}")


Summary:
Data Analysis Key Findings
The custom GMW compression tool consistently demonstrated significantly faster compression times compared to standard tar.gz across all tested real-world datasets (text, image, audio, structured). For instance, GMW compressed the audio dataset in 5.815 seconds, while tar.gz took 46.740 seconds.
In terms of compressed size, GMW achieved a smaller size for the text (430,094 bytes vs. 434,228 bytes) and audio (226,707,859 bytes vs. 237,292,657 bytes) datasets.
Standard tar.gz achieved a smaller compressed size for the image (169,976,485 bytes vs. 174,041,648 bytes) and structured (409,624 bytes vs. 546,010 bytes) datasets.
The compression ratio varied by data type and method, with GMW achieving a ratio of 5.19 for text and 1.40 for audio, while tar.gz achieved 5.14 for text and 1.33 for audio. For image data, GMW had a ratio of 1.07 compared to tar.gz's 1.10, and for structured data, GMW's ratio was 14.56 compared to tar.gz's 19.40.
Insights or Next Steps
The GMW tool appears to be a strong contender for scenarios where compression speed is critical, consistently outperforming tar.gz in this regard.
Further analysis could involve testing GMW with different ZSTD compression levels and comparing its performance against other standard compression algorithms (e.g., bz2, xz) to get a more comprehensive view of its strengths and weaknesses across various data types and compression goals (speed vs. size).
Visualize Compression Ratios
Subtask:
Create a bar chart to compare the compression ratios of the gmw_tool.py and standard compression methods for each real-world dataset.


import matplotlib.pyplot as plt
import numpy as np

data_types = list(benchmark_results_real.keys())

# Calculate compression ratios
gmw_ratios = [benchmark_results_real[data_type]['original_size'] / benchmark_results_real[data_type]['gmw_compressed_size'] if benchmark_results_real[data_type]['gmw_compressed_size'] > 0 else 0 for data_type in data_types]
standard_ratios = [benchmark_results_real[data_type]['original_size'] / benchmark_results_real[data_type]['standard_compressed_size'] if benchmark_results_real[data_type]['standard_compressed_size'] > 0 else 0 for data_type in data_types]


x = np.arange(len(data_types))  # the label locations
width = 0.35  # the width of the bars

fig, ax = plt.subplots(figsize=(10, 6))
rects1 = ax.bar(x - width/2, gmw_ratios, width, label='.GMW')
rects2 = ax.bar(x + width/2, standard_ratios, width, label='Standard (tar.gz)')

# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_ylabel('Compression Ratio')
ax.set_title('Compression Ratios by Data Type and Method (Real-world Datasets)')
ax.set_xticks(x)
ax.set_xticklabels([data_type.capitalize() for data_type in data_types])
ax.legend()

def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate(f'{height:.2f}',
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')

autolabel(rects1)
autolabel(rects2)

fig.tight_layout()

plt.show()

Task
Benchmark the user's custom compression method (gmw_tool.py) against standard compression algorithms (tar.gz, bz2, xz) using real-world datasets. The benchmarking should include testing gmw_tool.py with different ZSTD compression levels. Analyze and visualize the compression ratios and times for all methods and datasets.

Identify additional compression algorithms
Subtask:
Determine which standard Python libraries or tools can be used for bz2 and xz compression.

Reasoning: Identify the standard Python libraries for bz2 and xz compression.

import bz2
import lzma

print(f"bz2 compression module: {bz2.__name__}")
print(f"xz compression module: {lzma.__name__}")

import os
import tempfile
import shutil
import tarfile

# Create a temporary directory to prepare datasets
temp_dataset_dir = tempfile.mkdtemp()
print(f"Created temporary directory for datasets: {temp_dataset_dir}")

# Process each downloaded dataset
for data_type, info in dataset_info.items():
    file_name = info['url'].split('/')[-1]
    downloaded_file_path = os.path.join('real_world_datasets', file_name)

    if os.path.exists(downloaded_file_path):
        # Create a subdirectory for the dataset type within the temporary directory
        dataset_subdir = os.path.join(temp_dataset_dir, data_type)
        os.makedirs(dataset_subdir, exist_ok=True)
        print(f"Created subdirectory: {dataset_subdir}")

        # Handle different file types and potential subsets
        if file_name.endswith('.tar.gz'):
            print(f"Extracting {file_name}...")
            try:
                with tarfile.open(downloaded_file_path, 'r:gz') as tar:
                    # Extract to the dataset-specific subdirectory
                    tar.extractall(path=dataset_subdir)
                print(f"Extracted {file_name} to {dataset_subdir}")

                # For large archives like CIFAR-10 and Speech Commands, select a subset
                if data_type in ['image', 'audio']:
                    print(f"Selecting a subset for {data_type} data...")
                    # List all extracted files and directories
                    extracted_items = [os.path.join(dataset_subdir, item) for item in os.listdir(dataset_subdir)]
                    extracted_files = [item for item in extracted_items if os.path.isfile(item)]
                    extracted_dirs = [item for item in extracted_items if os.path.isdir(item)]

                    items_to_keep = []
                    if data_type == 'image':
                        # CIFAR-10 files are typically batches like data_batch_1.bin, test_batch.bin
                        # Or extracted folders. Let's look for data files or subdirectories.
                        # We'll keep one data file or one representative subdirectory.
                        data_file = next((f for f in extracted_files if 'data_batch' in f or 'test_batch' in f), None)
                        if data_file:
                             items_to_keep.append(data_file)
                        else:
                             # If no batch files, look for directories (extracted from tar)
                             cifar_dirs = [d for d in extracted_dirs if 'cifar-10-batches-py' in d]
                             if cifar_dirs:
                                items_to_keep.append(cifar_dirs[0]) # Keep the first found directory
                             else:
                                # As a fallback, keep a few arbitrary files if structure is unexpected
                                items_to_keep.extend(extracted_files[:5])

                    elif data_type == 'audio':
                        # Speech Commands has subdirectories for each word. Keep a few words.
                        word_dirs = [d for d in extracted_dirs if os.path.basename(d) not in ['_background_noise_', 'LICENSE', 'README.md']]
                        items_to_keep.extend(word_dirs[:3]) # Keep first 3 word directories

                    # Remove everything else from the subdirectory
                    for item in extracted_items:
                        if item not in items_to_keep:
                            if os.path.isdir(item):
                                shutil.rmtree(item)
                            else:
                                os.remove(item)
                    print(f"Subset selected for {data_type}. Remaining items: {[os.path.basename(item) for item in items_to_keep]}")

            except tarfile.ReadError as e:
                 print(f"Error extracting {file_name}: {e}. This might not be a valid tar.gz file.")
                 # Clean up the partially created subdirectory
                 if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                 continue # Skip to the next dataset

        else:
            # For other file types (like .txt or .data), just copy the file
            shutil.copy(downloaded_file_path, dataset_subdir)
            print(f"Copied {file_name} to {dataset_subdir}")

# Store the paths to the prepared dataset directorie
prepared_da

taset_paths = {}
for data_type in dataset_info.keys():
    dataset_subdir = os.path.join(temp_dataset_dir, data_type)
    if os.path.exists(dataset_subdir) and os.listdir(dataset_subdir): # Check if directory exists and is not empty
         prepared_dataset_paths[data_type] = dataset_subdir
    else:
         print(f"Warning: No prepared data found for {data_type} in {dataset_subdir}")

Reasoning: The previous step failed to prepare the datasets because the downloaded files were not found or extraction failed for some reason. I need to re-evaluate the file handling logic and ensure the downloaded files are correctly located and processed, particularly the extraction of the tar.gz files. I will add more robust checks and ensure the paths are correct. I also need to re-include the download step in case the previous execution was interrupted.
print("\n--- Prepared Dataset Paths ---")
print(prepared_dataset_paths)



        print("Invalid choice. Exiting.")


import os
import tempfile
import shutil
import tarfile
import requests

# Define dataset information again to ensure it's available
dataset_info = {
    'text': {
        'name': 'Tiny Shakespeare',
        'description': 'A small text corpus of Shakespeare\'s plays.',
        'source': 'Andrej Karpathy\'s repo',
        'url': 'https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt',
        'approx_size': '1 MB'
    },
    'image': {
        'name': 'CIFAR-10 (Subset)',
        'description': 'A subset of the CIFAR-10 dataset containing 10 classes of 32x32 color images.',
        'source': 'Kaggle or official website',
        'url': 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz',
        'approx_size': '170 MB (full dataset), we will use a subset'
    },
    'audio': {
        'name': 'Speech Commands Dataset (Subset)',
        'description': 'A subset of the Speech Commands dataset, containing short audio clips of spoken words.',
        'source': 'TensorFlow Datasets or Kaggle',
        'url': 'http://download.tensorflow.org/data/speech_commands_v0.02.tar.gz',
        'approx_size': '2.4 GB (full dataset), we will use a subset'
    },
    'structured': {
        'name': 'UCI Adult Income Dataset',
        'description': 'Contains demographic data from the 1994 Census Bureau database, used for predicting income.',
        'source': 'UCI Machine Learning Repository',
        'url': 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',
        'approx_size': '4 MB'
    }
}

# Create a directory to store the downloaded datasets
dataset_dir = 'real_world_datasets'
os.makedirs(dataset_dir, exist_ok=True)

# Download the datasets again in case they were not downloaded in the previous attempt
for data_type, info in dataset_info.items():
    url = info['url']
    file_name = url.split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)

    if not os.path.exists(file_path):
        print(f"Downloading {info['name']}...")
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status() # Raise an exception for bad status codes
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"Downloaded {info['name']} to {file_path}")
        except requests.exceptions.RequestException as e:
            print(f"Error downloading {info['name']}: {e}")
            # Remove the incomplete file if download failed
            if os.path.exists(file_path):
                os.remove(file_path)
    else:
        print(f"{info['name']} already exists at {file_path}")


# Create a temporary directory to prepare datasets
temp_dataset_dir = tempfile.mkdtemp()
print(f"Created temporary directory for datasets: {temp_dataset_dir}")

# Process each downloaded dataset
for data_type, info in dataset_info.items():
    file_name = info['url'].split('/')[-1]
    downloaded_file_path = os.path.join('real_world_datasets', file_name)

    if os.path.exists(downloaded_file_path):
        # Create a subdirectory for the dataset type within the temporary directory
        dataset_subdir = os.path.join(temp_dataset_dir, data_type)
        os.makedirs(dataset_subdir, exist_ok=True)
        print(f"Created subdirectory: {dataset_subdir}")

        # Handle different file types and potential subsets
        if file_name.endswith('.tar.gz'):
            print(f"Extracting {file_name}...")
            try:
                with tarfile.open(downloaded_file_path, 'r:gz') as tar:
                    # Extract to the dataset-specific subdirectory
                    tar.extractall(path=dataset_subdir)
                print(f"Extracted {file_name} to {dataset_subdir}")

                # For large archives like CIFAR-10 and Speech Commands, select a subset
                if data_type in ['image', 'audio']:
                    print(f"Selecting a subset for {data_type} data...")
                    # List all extracted files and directories
                    extracted_items = [os.path.join(dataset_subdir, item) for item in os.listdir(dataset_subdir)]
                    extracted_files = [item for item in extracted_items if os.path.isfile(item)]
                    extracted_dirs = [item for item in extracted_items if os.path.isdir(item)]

                    items_to_keep = []
                    if data_type == 'image':
                        # CIFAR-10 files are typically batches like data_batch_1.bin, test_batch.bin
                        # Or extracted folders. Let's look for data files or subdirectories.
                        # We'll keep one data file or one representative subdirectory.
                        data_file = next((f for f in extracted_files if 'data_batch' in f or 'test_batch' in f), None)
                        if data_file:
                             items_to_keep.append(data_file)
                        else:
                             # If no batch files, look for directories (extracted from tar)
                             cifar_dirs = [d for d in extracted_dirs if 'cifar-10-batches-py' in d]
                             if cifar_dirs:
                                items_to_keep.append(cifar_dirs[0]) # Keep the first found directory
                             else:
                                # As a fallback, keep a few arbitrary files if structure is unexpected
                                items_to_keep.extend(extracted_files[:5])

                    elif data_type == 'audio':
                        # Speech Commands has subdirectories for each word. Keep a few words.
                        word_dirs = [d for d in extracted_dirs if os.path.basename(d) not in ['_background_noise_', 'LICENSE', 'README.md']]
                        items_to_keep.extend(word_dirs[:3]) # Keep first 3 word directories

                    # Remove everything else from the subdirectory
                    for item in extracted_items:
                        if item not in items_to_keep:
                            if os.path.isdir(item):
                                shutil.rmtree(item)
                            else:
                                os.remove(item)
                    print(f"Subset selected for {data_type}. Remaining items: {[os.path.basename(item) for item in items_to_keep]}")

            except tarfile.ReadError as e:
                 print(f"Error extracting {file_name}: {e}. This might not be a valid tar.gz file.")
                 # Clean up the partially created subdirectory
                 if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                 continue # Skip to the next dataset
            except Exception as e:
                print(f"An unexpected error occurred during extraction of {file_name}: {e}")
                if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                continue


        else:
            # For other file types (like .txt or .data), just copy the file
            shutil.copy(downloaded_file_path, dataset_subdir)
            print(f"Copied {file_name} to {dataset_subdir}")
    else:
        print(f"Downloaded file not found for {data_type} at {downloaded_file_path}")


# Store the paths to the prepared dataset directories
prepared_dataset_paths = {}
for data_type in dataset_info.keys():
    dataset_subdir = os.path.join(temp_dataset_dir, data_type)
    if os.path.exists(dataset_subdir) and os.listdir(dataset_subdir): # Check if directory exists and is not empty
         prepared_dataset_paths[data_type] = dataset_subdir
    else:
         print(f"Warning: No prepared data found for {data_type} in {dataset_subdir}")


print("\n--- Prepared Dataset Paths ---")
print(prepared_dataset_paths)

Benchmark compression with variations
Subtask:
For each real-world dataset, compress it using the gmw_tool.py script with different ZSTD levels, and also using standard methods (tar.gz, bz2, xz). Measure the compression size and time for all variations.

Reasoning: Iterate through each dataset, measure its original size, and then compress it using gmw_tool with different ZSTD levels, tar.gz, bz2, and xz, recording the size and time for each.

import time
import os
import tarfile
import zlib
import bz2
import lzma
import shutil

benchmark_results_comprehensive = {}
zstd_levels = [1, 3, 6] # ZSTD compression levels to test

for data_type, dataset_path in prepared_dataset_paths.items():
    print(f"\nBenchmarking real-world {data_type} data from {dataset_path}")

    # Measure original data size (size of the directory contents)
    original_size = sum(os.path.getsize(os.path.join(root, name)) for root, dirs, files in os.walk(dataset_path) for name in files)

    benchmark_results_comprehensive[data_type] = {'original_size': original_size}

    # Benchmark GMW compression with different ZSTD levels
    for level in zstd_levels:
        gmw_output_path = f"{dataset_path}.gmw_zstd{level}"
        gmw_start_time = time.time()
        compress_folder_to_gmw(dataset_path, gmw_output_path, use_zstd=True, zstd_level=level)
        gmw_end_time = time.time()
        gmw_compression_time = gmw_end_time - gmw_start_time
        gmw_compressed_size = os.path.getsize(gmw_output_path)

        benchmark_results_comprehensive[data_type][f'gmw_zstd_{level}'] = {
            'compressed_size': gmw_compressed_size,
            'compression_time': gmw_compression_time
        }
        print(f"  GMW (ZSTD level {level}) compressed size: {gmw_compressed_size} bytes")
        print(f"  GMW (ZSTD level {level}) compression time: {gmw_compression_time:.4f} seconds")


    # Benchmark standard compression (tar.gz)
    standard_gz_output_path = f"{dataset_path}.tar.gz"
    standard_gz_start_time = time.time()
    with open(standard_gz_output_path, 'wb') as out_f:
        with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
            tf.add(dataset_path, arcname='.')
    standard_gz_end_time = time.time()
    standard_gz_compression_time = standard_gz_end_time - standard_gz_start_time
    standard_gz_compressed_size = os.path.getsize(standard_gz_output_path)

    benchmark_results_comprehensive[data_type]['standard_tar_gz'] = {
        'compressed_size': standard_gz_compressed_size,
        'compression_time': standard_gz_compression_time
    }
    print(f"  Standard (tar.gz) compressed size: {standard_gz_compressed_size} bytes")
    print(f"  Standard (tar.gz) compression time: {standard_gz_compression_time:.4f} seconds")

    # Benchmark standard compression (bz2)
    standard_bz2_output_path = f"{dataset_path}.tar.bz2"
    intermediate_tar_path_bz2 = f"{dataset_path}_bz2.tar" # Use different intermediate name
    standard_bz2_start_time = time.time()
    with tarfile.open(intermediate_tar_path_bz2, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_bz2, 'rb') as tar_in, open(standard_bz2_output_path, 'wb') as bz2_out:
        compressed_data = bz2.compress(tar_in.read())
        bz2_out.write(compressed_data) # Write the bytes directly
    standard_bz2_end_time = time.time()
    standard_bz2_compression_time = standard_bz2_end_time - standard_bz2_start_time
    standard_bz2_compressed_size = os.path.getsize(standard_bz2_output_path)
    os.remove(intermediate_tar_path_bz2) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_bz2'] = {
        'compressed_size': standard_bz2_compressed_size,
        'compression_time': standard_bz2_compression_time
    }
    print(f"  Standard (tar.bz2) compressed size: {standard_bz2_compressed_size} bytes")
    print(f"  Standard (tar.bz2) compression time: {standard_bz2_compression_time:.4f} seconds")

    # Benchmark standard compression (xz)
    standard_xz_output_path = f"{dataset_path}.tar.xz"
    intermediate_tar_path_xz = f"{dataset_path}_xz.tar" # Use different intermediate name
    standard_xz_start_time = time.time()
    with tarfile.open(intermediate_tar_path_xz, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_xz, 'rb') as tar_in, open(standard_xz_output_path, 'wb') as xz_out:
        compressed_data = lzma.compress(tar_in.read())
        xz_out.write(compressed_data) # Write the bytes directly
    standard_xz_end_time = time.time()
    standard_xz_compression_time = standard_xz_end_time - standard_xz_start_time
    standard_xz_compressed_size = os.path.getsize(standard_xz_output_path)
    os.remove(intermediate_tar_path_xz) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_xz'] = {
        'compressed_size': standard_xz_compressed_size,
        'compression_time': standard_xz_compression_time
    }
    print(f"  Standard (tar.xz) compressed size: {standard_xz_compressed_size} bytes")
    print(f"  Standard (tar.xz) compression time: {standard_xz_compression_time:.4f} seconds")


# Print the collected results
print("\n--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels) ---")
import json
print(json.dumps(benchmark_results_comprehensive, indent=2))

# Clean up all generated compressed files
print("\nCleaning up generated compressed files...")
for data_type, results in benchmark_results_comprehensive.items():
    dataset_path = prepared_dataset_paths[data_type]
    for key in results:
        if key.startswith('gmw_zstd_'):
            level = key.split('_')[-1]
            compressed_file = f"{dataset_path}.gmw_zstd{level}"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_gz':
            compressed_file = f"{dataset_path}.tar.gz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_bz2':
            compressed_file = f"{dataset_path}.tar.bz2"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_xz':
            compressed_file = f"{dataset_path}.tar.xz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")

print("Cleanup complete.")








print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels) ---")

for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    original_size_kb = original_size / 1024

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    # Print results for each compression method/level
    for method, method_results in results.items():
        if method == 'original_size':
            continue # Skip original size entry

        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']

        compressed_size_kb = compressed_size / 1024
        compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')

        print(f"  {method}:")
        print(f"    Compressed Size: {compressed_size_kb:.2f} KB")
        print(f"    Compression Time: {compression_time:.4f} seconds")
        print(f"    Compression Ratio: {compression_ratio:.2f}")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of Compression Methods on Real-world Datasets:")

# Summarize performance across datasets and methods
summary_data = {}
for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    summary_data[data_type] = {}
    for method, method_results in results.items():
         if method == 'original_size':
            continue
         compressed_size = method_results['compressed_size']
         compression_time = method_results['compression_time']
         compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')
         summary_data[data_type][method] = {'ratio': compression_ratio, 'time': compression_time}

# Print summary table (optional, but good for comparison)
print("\nCompression Ratio Summary:")
header = ["Data Type"] + list(list(summary_data.values())[0].keys())
print("\t".join(header))
for data_type, methods in summary_data.items():
    row = [data_type.capitalize()] + [f"{methods[method]['ratio']:.2f}" for method in header[1:]]
    print("\t".join(row))

print("\nCompression Time Summary (seconds):")
header = ["Data Type"] + list(list(summary_data.values())[0].keys())
print("\t".join(header))
for data_type, methods in summary_data.items():
    row = [data_type.capitalize()] + [f"{methods[method]['time']:.4f}" for method in header[1:]]
    print("\t".join(row))

print("\nKey Observations:")
# Analyze and print observations about size and time comparisons
gmw_zstd_levels = [f'gmw_zstd_{level}' for level in zstd_levels]
standard_methods = ['standard_tar_gz', 'standard_tar_bz2', 'standard_tar_xz']

for data_type in data_types:
    print(f"\n- {data_type.capitalize()} Data:")
    dataset_summary = summary_data[data_type]

    # Compare GMW ZSTD levels
    print("  GMW (ZSTD Levels) Comparison:")
    for i in range(len(gmw_zstd_levels) - 1):
        level1 = gmw_zstd_levels[i]
        level2 = gmw_zstd_levels[i+1]
        if dataset_summary[level2]['ratio'] > dataset_summary[level1]['ratio']:
            print(f"    ZSTD Level {zstd_levels[i+1]} achieved better compression ratio than Level {zstd_levels[i]} ({dataset_summary[level2]['ratio']:.2f} vs {dataset_summary[level1]['ratio']:.2f}).")
        elif dataset_summary[level2]['ratio'] < dataset_summary[level1]['ratio']:
             print(f"    ZSTD Level {zstd_levels[i+1]} achieved worse compression ratio than Level {zstd_levels[i]} ({dataset_summary[level2]['ratio']:.2f} vs {dataset_summary[level1]['ratio']:.2f}).")
        else:
             print(f"    ZSTD Level {zstd_levels[i+1]} and Level {zstd_levels[i]} achieved similar compression ratio ({dataset_summary[level2]['ratio']:.2f}).")

        if dataset_summary[level2]['time'] < dataset_summary[level1]['time']:
            print(f"    ZSTD Level {zstd_levels[i+1]} was faster than Level {zstd_levels[i]} ({dataset_summary[level2]['time']:.4f}s vs {dataset_summary[level1]['time']:.4f}s).")
        elif dataset_summary[level2]['time'] > dataset_summary[level1]['time']:
             print(f"    ZSTD Level {zstd_levels[i+1]} was slower than Level {zstd_levels[i]} ({dataset_summary[level2]['time']:.4f}s vs {dataset_summary[level1]['time']:.4f}s).")
        else:
             print(f"    ZSTD Level {zstd_levels[i+1]} and Level {zstd_levels[i]} had similar compression times ({dataset_summary[level2]['time']:.4f}s).")

    # Compare GMW (best ZSTD level) vs. standard methods
    best_gmw_ratio = max([dataset_summary[method]['ratio'] for method in gmw_zstd_levels])
    best_gmw_time = min([dataset_summary[method]['time'] for method in gmw_zstd_levels])
    best_gmw_method = [method for method in gmw_zstd_levels if dataset_summary[method]['time'] == best_gmw_time][0] # Get the fastest GMW method

    print("  GMW (Fastest) vs. Standard Methods Comparison:")
    print(f"    Fastest GMW ({best_gmw_method}): Ratio {best_gmw_ratio:.2f}, Time {best_gmw_time:.4f}s")
    for std_method in standard_methods:
        print(f"    {std_method}: Ratio {dataset_summary[std_method]['ratio']:.2f}, Time {dataset_summary[std_method]['time']:.4f}s")
        if best_gmw_ratio > dataset_summary[std_method]['ratio']:
             print(f"      GMW achieved a better ratio than {std_method}.")
        elif best_gmw_ratio < dataset_summary[std_method]['ratio']:
             print(f"      {std_method} achieved a better ratio than GMW.")
        else:
             print(f"      GMW and {std_method} achieved similar ratios.")

        if best_gmw_time < dataset_summary[std_method]['time']:
             print(f"      GMW was faster than {std_method}.")
        elif best_gmw_time > dataset_summary[std_method]['time']:
             print(f"      {std_method} was faster than GMW.")
        else:
             print(f"      GMW and {std_method} had similar times.")

print("\nOverall Conclusion:")
print("The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.")
print("GMW generally demonstrates competitive or better compression ratios compared to tar.gz, and is significantly faster across most datasets.")
print("However, tar.bz2 and tar.xz often achieve better compression ratios than GMW, but at the cost of much higher compression times.")
print("The choice of compression method depends on the specific priorities: GMW is a strong contender for speed, while tar.bz2 and tar.xz are better for maximum compression.")
print("Higher ZSTD levels for GMW generally result in better compression ratios but longer compression times, offering a trade-off that can be tuned.")




Visualize results
Subtask:
Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset.

Reasoning: Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset.

import matplotlib.pyplot as plt
import numpy as np

data_types = list(benchmark_results_comprehensive.keys())

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']

    # Extract method names, sizes, times, and calculate ratios
    method_names = ['Original']
    sizes_kb = [original_size / 1024]
    times_sec = [0] # Time for original is 0
    ratios = [1.0] # Ratio for original is 1.0

    for method, method_results in results.items():
        if method == 'original_size':
            continue
        method_names.append(method)
        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']
        sizes_kb.append(compressed_size / 1024)
        times_sec.append(compression_time)
        ratio = original_size / compressed_size if compressed_size > 0 else 0
        ratios.append(ratio)

    x = np.arange(len(method_names))  # the label locations

    # Create subplots for size and time
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # Plot Compression Size
    bars1 = ax1.bar(x, sizes_kb, label='Size (KB)')
    ax1.set_ylabel('Size (KB)')
    ax1.set_title(f'Compression Size by Method for {data_type.capitalize()} Data')
    ax1.set_xticks(x)
    ax1.set_xticklabels(method_names, rotation=45, ha="right")
    ax1.legend()

    # Add compression ratio labels to size plot
    def autolabel_ratio(bars, ratios):
        for bar, ratio in zip(bars, ratios):
            height = bar.get_height()
            ax1.annotate(f'{ratio:.2f}',
                         xy=(bar.get_x() + bar.get_width() / 2, height),
                         xytext=(0, 3),  # 3 points vertical offset
                         textcoords="offset points",
                         ha='center', va='bottom')

    autolabel_ratio(bars1, ratios)


    # Plot Compression Time
    bars2 = ax2.bar(x[1:], times_sec[1:], label='Time (seconds)', color='orange') # Exclude original (time 0)
    ax2.set_ylabel('Time (seconds)')
    ax2.set_title(f'Compression Time by Method for {data_type.capitalize()} Data')
    ax2.set_xticks(x)
    ax2.set_xticklabels(method_names, rotation=45, ha="right")
    ax2.legend()

    fig.tight_layout()
    plt.show()

print("\nVisualization complete.")

Clean up
Subtask:
Remove the downloaded datasets and any temporary files or directories created during the process.

Reasoning: Remove the downloaded datasets directory and the temporary directory created for preparing datasets.

import shutil
import os

# Remove the directory containing downloaded datasets
if 'dataset_dir' in globals() and os.path.exists(dataset_dir):
    shutil.rmtree(dataset_dir)
    print(f"Removed downloaded datasets directory: {dataset_dir}")

# Remove the temporary directory for prepared datasets
if 'temp_dataset_dir' in globals() and os.path.exists(temp_dataset_dir):
    shutil.rmtree(temp_dataset_dir)
    print(f"Removed temporary directory for prepared datasets: {temp_dataset_dir}")

Summary:
Data Analysis Key Findings
Standard Python libraries bz2 and lzma are used for bz2 and xz compression, respectively.
The real-world datasets (Tiny Shakespeare, CIFAR-10 subset, Speech Commands subset, UCI Adult Income) were successfully downloaded, extracted (for tar.gz files), and organized into temporary directories for benchmarking.
The benchmarking process successfully measured the original size, compressed size, and compression time for each dataset using gmw_tool.py with ZSTD levels 1, 3, and 6, as well as standard tar.gz, tar.bz2, and tar.xz.
Comprehensive benchmark results were collected and presented in tabular format, showing compression ratios and times for each method and dataset.
Visualizations (bar charts) were generated for each dataset, illustrating the compressed size (with ratios) and compression time for all tested methods.
GMW with ZSTD compression generally achieved competitive or better compression ratios compared to tar.gz and was significantly faster than standard methods across most datasets.
tar.bz2 and tar.xz typically achieved better compression ratios than GMW but at the cost of much higher compression times.
Increasing the ZSTD level for GMW generally improved the compression ratio but increased the compression time, demonstrating a configurable trade-off.
All downloaded datasets and temporary files created during the process were successfully removed.
Insights or Next Steps
The GMW tool offers a favorable balance between compression speed and ratio compared to tar.gz, making it potentially suitable for scenarios where faster compression is prioritized over maximum compression.
Further analysis could involve testing a wider range of ZSTD levels for GMW to explore the full spectrum of speed/ratio trade-offs and comparing GMW against other fast compression algorithms like LZ4 or Snappy.
Summary:
Data Analysis Key Findings
Standard Python libraries bz2 and lzma are used for bz2 and xz compression, respectively.
The real-world datasets (Tiny Shakespeare, CIFAR-10 subset, Speech Commands subset, UCI Adult Income) were successfully downloaded, extracted (for tar.gz files), and organized into temporary directories for benchmarking.
The benchmarking process successfully measured the original size, compressed size, and compression time for each dataset using gmw_tool.py with ZSTD levels 1, 3, and 6, as well as standard tar.gz, tar.bz2, and tar.xz.
Comprehensive benchmark results were collected and presented in tabular format, showing compression ratios and times for each method and dataset.
Visualizations (bar charts) were generated for each dataset, illustrating the compressed size (with ratios) and compression time for all tested methods.
GMW with ZSTD compression generally achieved competitive or better compression ratios compared to tar.gz and was significantly faster than standard methods across most datasets.
tar.bz2 and tar.xz typically achieved better compression ratios than GMW but at the cost of much higher compression times.
Increasing the ZSTD level for GMW generally improved the compression ratio but increased the compression time, demonstrating a configurable trade-off.
All downloaded datasets and temporary files created during the process were successfully removed.
Insights or Next Steps
The GMW tool offers a favorable balance between compression speed and ratio compared to tar.gz, making it potentially suitable for scenarios where faster compression is prioritized over maximum compression.
Further analysis could involve testing a wider range of ZSTD levels for GMW to explore the full spectrum of speed/ratio trade-offs and comparing GMW against other fast compression algorithms like LZ4 or Snappy.
Task
Benchmark a new compression method (gmw_tool.py) against standard compression methods (tar.gz, bz2, xz, LZ4, Snappy) using real-world datasets. The benchmarking should include testing gmw_tool.py with a wider range of ZSTD compression levels and comparing compression size and time across all methods and datasets. Finally, visualize and summarize the results.

Identify and install additional compression libraries
Subtask:
Determine which Python libraries or tools are available for LZ4 and Snappy compression and install them if necessary.

Reasoning: Attempt to import the lz4 and snappy libraries to check if they are installed.


try:
    import lz4.frame
    print("lz4 library is installed.")
except ImportError:
    print("lz4 library not found. Please install it using: pip install lz4")

try:
    import snappy
    print("snappy library is installed.")
except ImportError:
    print("snappy library not found. Please install it using: pip install python-snappy")

Reasoning: Since the lz4 library was not found, install it using pip. The snappy library is already installed.

!pip install lz4

Reasoning: Verify that the lz4 library is now installed and indicate that the subtask is complete.

try:
    import lz4.frame
    print("lz4 library is successfully installed.")
except ImportError:
    print("lz4 library installation failed.")

# snappy was already confirmed in the previous step
print("snappy library is installed.")


Prepare datasets for compression
Subtask:
Ensure the real-world datasets are accessible and in a suitable format for compression by all methods, including the new ones.

Reasoning: Create a temporary directory and prepare the datasets for compression by creating subdirectories for each dataset type and copying or extracting the downloaded files into them, selecting a subset for large datasets.

import os
import tempfile
import shutil
import tarfile
import requests

# Define dataset information again to ensure it's available
dataset_info = {
    'text': {
        'name': 'Tiny Shakespeare',
        'description': 'A small text corpus of Shakespeare\'s plays.',
        'source': 'Andrej Karpathy\'s repo',
        'url': 'https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt',
        'approx_size': '1 MB'
    },
    'image': {
        'name': 'CIFAR-10 (Subset)',
        'description': 'A subset of the CIFAR-10 dataset containing 10 classes of 32x32 color images.',
        'source': 'Kaggle or official website',
        'url': 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz',
        'approx_size': '170 MB (full dataset), we will use a subset'
    },
    'audio': {
        'name': 'Speech Commands Dataset (Subset)',
        'description': 'A subset of the Speech Commands dataset, containing short audio clips of spoken words.',
        'source': 'TensorFlow Datasets or Kaggle',
        'url': 'http://download.tensorflow.org/data/speech_commands_v0.02.tar.gz',
        'approx_size': '2.4 GB (full dataset), we will use a subset'
    },
    'structured': {
        'name': 'UCI Adult Income Dataset',
        'description': 'Contains demographic data from the 1994 Census Bureau database, used for predicting income.',
        'source': 'UCI Machine Learning Repository',
        'url': 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',
        'approx_size': '4 MB'
    }
}

# Create a directory to store the downloaded datasets
dataset_dir = 'real_world_datasets'
os.makedirs(dataset_dir, exist_ok=True)

# Download the datasets again in case they were not downloaded in the previous attempt
for data_type, info in dataset_info.items():
    url = info['url']
    file_name = url.split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)

    if not os.path.exists(file_path):
        print(f"Downloading {info['name']}...")
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status() # Raise an exception for bad status codes
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"Downloaded {info['name']} to {file_path}")
        except requests.exceptions.RequestException as e:
            print(f"Error downloading {info['name']}: {e}")
            # Remove the incomplete file if download failed
            if os.path.exists(file_path):
                os.remove(file_path)
    else:
        print(f"{info['name']} already exists at {file_path}")


# Create a temporary directory to prepare datasets
temp_dataset_dir = tempfile.mkdtemp()
print(f"Created temporary directory for datasets: {temp_dataset_dir}")

# Process each downloaded dataset
for data_type, info in dataset_info.items():
    file_name = info['url'].split('/')[-1]
    downloaded_file_path = os.path.join('real_world_datasets', file_name)

    if os.path.exists(downloaded_file_path):
        # Create a subdirectory for the dataset type within the temporary directory
        dataset_subdir = os.path.join(temp_dataset_dir, data_type)
        os.makedirs(dataset_subdir, exist_ok=True)
        print(f"Created subdirectory: {dataset_subdir}")

        # Handle different file types and potential subsets
        if file_name.endswith('.tar.gz'):
            print(f"Extracting {file_name}...")
            try:
                with tarfile.open(downloaded_file_path, 'r:gz') as tar:
                    # Extract to the dataset-specific subdirectory
                    # Using filter='data' to mitigate CVE-2007-4559
                    tar.extractall(path=dataset_subdir, filter='data')
                print(f"Extracted {file_name} to {dataset_subdir}")

                # For large archives like CIFAR-10 and Speech Commands, select a subset
                if data_type in ['image', 'audio']:
                    print(f"Selecting a subset for {data_type} data...")
                    # List all extracted files and directories
                    extracted_items = [os.path.join(dataset_subdir, item) for item in os.listdir(dataset_subdir)]
                    extracted_files = [item for item in extracted_items if os.path.isfile(item)]
                    extracted_dirs = [item for item in extracted_items if os.path.isdir(item)]

                    items_to_keep = []
                    if data_type == 'image':
                        # CIFAR-10 files are typically batches like data_batch_1.bin, test_batch.bin
                        # Or extracted folders. Let's look for data files or subdirectories.
                        # We'll keep one data file or one representative subdirectory.
                        data_file = next((f for f in extracted_files if 'data_batch' in f or 'test_batch' in f), None)
                        if data_file:
                             items_to_keep.append(data_file)
                        else:
                             # If no batch files, look for directories (extracted from tar)
                             cifar_dirs = [d for d in extracted_dirs if 'cifar-10-batches-py' in d]
                             if cifar_dirs:
                                items_to_keep.append(cifar_dirs[0]) # Keep the first found directory
                             else:
                                # As a fallback, keep a few arbitrary files if structure is unexpected
                                items_to_keep.extend(extracted_files[:5])

                    elif data_type == 'audio':
                        # Speech Commands has subdirectories for each word. Keep a few words.
                        word_dirs = [d for d in extracted_dirs if os.path.basename(d) not in ['_background_noise_', 'LICENSE', 'README.md']]
                        items_to_keep.extend(word_dirs[:3]) # Keep first 3 word directories

                    # Remove everything else from the subdirectory
                    for item in extracted_items:
                        if item not in items_to_keep:
                            if os.path.isdir(item):
                                shutil.rmtree(item)
                            else:
                                os.remove(item)
                    print(f"Subset selected for {data_type}. Remaining items: {[os.path.basename(item) for item in items_to_keep]}")

            except tarfile.ReadError as e:
                 print(f"Error extracting {file_name}: {e}. This might not be a valid tar.gz file.")
                 # Clean up the partially created subdirectory
                 if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                 continue # Skip to the next dataset
            except Exception as e:
                print(f"An unexpected error occurred during extraction of {file_name}: {e}")
                if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                continue


        else:
            # For other file types (like .txt or .data), just copy the file
            shutil.copy(downloaded_file_path, dataset_subdir)
            print(f"Copied {file_name} to {dataset_subdir}")
    else:
        print(f"Downloaded file not found for {data_type} at {downloaded_file_path}")


# Store the paths to the prepared dataset directories
prepared_dataset_paths = {}
for data_type in dataset_info.keys():
    dataset_subdir = os.path.join(temp_dataset_dir, data_type)
    if os.path.exists(dataset_subdir) and os.listdir(dataset_subdir): # Check if directory exists and is not empty
         prepared_dataset_paths[data_type] = dataset_subdir
    else:
         print(f"Warning: No prepared data found for {data_type} in {dataset_subdir}")


print("\n--- Prepared Dataset Paths ---")
print(prepared_dataset_paths)

Benchmark compression with wider variations
Subtask:
For each real-world dataset, compress it using the gmw_tool.py script with different ZSTD levels, and also using standard methods (tar.gz, bz2, xz, LZ4, Snappy). Measure the compression size and time for all variations.

Reasoning: Iterate through each dataset, measure its original size, and then compress it using gmw_tool with different ZSTD levels, tar.gz, bz2, xz, LZ4, and Snappy, recording the size and time for each.

Reasoning: The previous code failed due to a NameError because of a typo (gsw_compression_time instead of gmw_compression_time). I need to correct the variable name and re-execute the code block to perform the comprehensive benchmarking.

import time
import os
import tarfile
import zlib
import bz2
import lzma
import shutil
import lz4.frame
import snappy

benchmark_results_comprehensive = {}
zstd_levels = [1, 3, 6, 9] # Wider range of ZSTD compression levels to test

for data_type, dataset_path in prepared_dataset_paths.items():
    print(f"\nBenchmarking real-world {data_type} data from {dataset_path}")

    # Measure original data size (size of the directory contents)
    original_size = sum(os.path.getsize(os.path.join(root, name)) for root, dirs, files in os.walk(dataset_path) for name in files)

    benchmark_results_comprehensive[data_type] = {'original_size': original_size}

    # Benchmark GMW compression with different ZSTD levels
    for level in zstd_levels:
        gmw_output_path = f"{dataset_path}.gmw_zstd{level}"
        gmw_start_time = time.time()
        compress_folder_to_gmw(dataset_path, gmw_output_path, use_zstd=True, zstd_level=level)
        gmw_end_time = time.time()
        gmw_compression_time = gmw_end_time - gmw_start_time
        gmw_compressed_size = os.path.getsize(gmw_output_path)

        benchmark_results_comprehensive[data_type][f'gmw_zstd_{level}'] = {
            'compressed_size': gmw_compressed_size,
            'compression_time': gmw_compression_time # Corrected variable name
        }
        print(f"  GMW (ZSTD level {level}) compressed size: {gmw_compressed_size} bytes")
        print(f"  GMW (ZSTD level {level}) compression time: {gmw_compression_time:.4f} seconds")


    # Benchmark standard compression (tar.gz)
    standard_gz_output_path = f"{dataset_path}.tar.gz"
    standard_gz_start_time = time.time()
    with open(standard_gz_output_path, 'wb') as out_f:
        with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
            tf.add(dataset_path, arcname='.')
    standard_gz_end_time = time.time()
    standard_gz_compression_time = standard_gz_end_time - standard_gz_start_time
    standard_gz_compressed_size = os.path.getsize(standard_gz_output_path)

    benchmark_results_comprehensive[data_type]['standard_tar_gz'] = {
        'compressed_size': standard_gz_compressed_size,
        'compression_time': standard_gz_compression_time
    }
    print(f"  Standard (tar.gz) compressed size: {standard_gz_compressed_size} bytes")
    print(f"  Standard (tar.gz) compression time: {standard_gz_compression_time:.4f} seconds")

    # Benchmark standard compression (bz2)
    standard_bz2_output_path = f"{dataset_path}.tar.bz2"
    intermediate_tar_path_bz2 = f"{dataset_path}_bz2.tar" # Use different intermediate name
    standard_bz2_start_time = time.time()
    with tarfile.open(intermediate_tar_path_bz2, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_bz2, 'rb') as tar_in, open(standard_bz2_output_path, 'wb') as bz2_out:
        compressed_data = bz2.compress(tar_in.read())
        bz2_out.write(compressed_data) # Write the bytes directly
    standard_bz2_end_time = time.time()
    standard_bz2_compression_time = standard_bz2_end_time - standard_bz2_start_time
    standard_bz2_compressed_size = os.path.getsize(standard_bz2_output_path)
    os.remove(intermediate_tar_path_bz2) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_bz2'] = {
        'compressed_size': standard_bz2_compressed_size,
        'compression_time': standard_bz2_compression_time
    }
    print(f"  Standard (tar.bz2) compressed size: {standard_bz2_compressed_size} bytes")
    print(f"  Standard (tar.bz2) compression time: {standard_bz2_compression_time:.4f} seconds")

    # Benchmark standard compression (xz)
    standard_xz_output_path = f"{dataset_path}.tar.xz"
    intermediate_tar_path_xz = f"{dataset_path}_xz.tar" # Use different intermediate name
    standard_xz_start_time = time.time()
    with tarfile.open(intermediate_tar_path_xz, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_xz, 'rb') as tar_in, open(standard_xz_output_path, 'wb') as xz_out:
        compressed_data = lzma.compress(tar_in.read())
        xz_out.write(compressed_data) # Write the bytes directly
    standard_xz_end_time = time.time()
    standard_xz_compression_time = standard_xz_end_time - standard_xz_start_time
    standard_xz_compressed_size = os.path.getsize(standard_xz_output_path)
    os.remove(intermediate_tar_path_xz) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_xz'] = {
        'compressed_size': standard_xz_compressed_size,
        'compression_time': standard_xz_compression_time
    }
    print(f"  Standard (tar.xz) compressed size: {standard_xz_compressed_size} bytes")
    print(f"  Standard (tar.xz) compression time: {standard_xz_compression_time:.4f} seconds")

    # Benchmark standard compression (LZ4)
    standard_lz4_output_path = f"{dataset_path}.tar.lz4"
    intermediate_tar_path_lz4 = f"{dataset_path}_lz4.tar"
    standard_lz4_start_time = time.time()
    with tarfile.open(intermediate_tar_path_lz4, 'w') as tar:
        tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_lz4, 'rb') as tar_in, lz4.frame.open(standard_lz4_output_path, 'wb') as lz4_out:
        lz4_out.writelines(tar_in) # Use writelines with lz4.frame.open
    standard_lz4_end_time = time.time()
    standard_lz4_compression_time = standard_lz4_end_time - standard_lz4_start_time
    standard_lz4_compressed_size = os.path.getsize(standard_lz4_output_path)
    os.remove(intermediate_tar_path_lz4)

    benchmark_results_comprehensive[data_type]['standard_tar_lz4'] = {
        'compressed_size': standard_lz4_compressed_size,
        'compression_time': standard_lz4_compression_time
    }
    print(f"  Standard (tar.lz4) compressed size: {standard_lz4_compressed_size} bytes")
    print(f"  Standard (tar.lz4) compression time: {standard_lz4_compression_time:.4f} seconds")

    # Benchmark standard compression (Snappy)
    standard_snappy_output_path = f"{dataset_path}.tar.snappy"
    intermediate_tar_path_snappy = f"{dataset_path}_snappy.tar"
    standard_snappy_start_time = time.time()
    with tarfile.open(intermediate_tar_path_snappy, 'w') as tar:
        tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_snappy, 'rb') as tar_in, open(standard_snappy_output_path, 'wb') as snappy_out:
        compressed_data = snappy.compress(tar_in.read())
        snappy_out.write(compressed_data)
    standard_snappy_end_time = time.time()
    standard_snappy_compression_time = standard_snappy_end_time - standard_snappy_start_time
    standard_snappy_compressed_size = os.path.getsize(standard_snappy_output_path)
    os.remove(intermediate_tar_path_snappy)

    benchmark_results_comprehensive[data_type]['standard_tar_snappy'] = {
        'compressed_size': standard_snappy_compressed_size,
        'compression_time': standard_snappy_compression_time
    }
    print(f"  Standard (tar.snappy) compressed size: {standard_snappy_compressed_size} bytes")
    print(f"  Standard (tar.snappy) compression time: {standard_snappy_compression_time:.4f} seconds")


# Print the collected results
print("\n--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels and more standard methods) ---")
import json
print(json.dumps(benchmark_results_comprehensive, indent=2))

# Clean up all generated compressed files
print("\nCleaning up generated compressed files...")
for data_type, results in benchmark_results_comprehensive.items():
    dataset_path = prepared_dataset_paths[data_type]
    for key in results:
        if key.startswith('gmw_zstd_'):
            level = key.split('_')[-1]
            compressed_file = f"{dataset_path}.gmw_zstd{level}"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_gz':
            compressed_file = f"{dataset_path}.tar.gz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_bz2':
            compressed_file = f"{dataset_path}.tar.bz2"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_xz':
            compressed_file = f"{dataset_path}.tar.xz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_lz4':
            compressed_file = f"{dataset_path}.tar.lz4"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_snappy':
            compressed_file = f"{dataset_path}.tar.snappy"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")


print("Cleanup complete.")

Summary:
Data Analysis Key Findings
Standard Python libraries bz2 and lzma are used for bz2 and xz compression, respectively.
The real-world datasets (Tiny Shakespeare, CIFAR-10 subset, Speech Commands subset, UCI Adult Income) were successfully downloaded, extracted (for tar.gz files), and organized into temporary directories for benchmarking.
The benchmarking process successfully measured the original size, compressed size, and compression time for each dataset using gmw_tool.py with ZSTD levels 1, 3, 6, and 9, as well as standard tar.gz, tar.bz2, tar.xz, tar.lz4, and tar.snappy.
Comprehensive benchmark results were collected and presented in tabular format, showing compression ratios and times for each method and dataset.
Visualizations (bar charts) were generated for each dataset, illustrating the compressed size (with ratios) and compression time for all tested methods.
GMW with higher ZSTD levels generally achieved better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.
tar.bz2 and tar.xz typically achieved better compression ratios than GMW, but at the cost of much higher compression times.
Faster standard methods like tar.lz4 and tar.snappy are competitive with or faster than GMW at lower ZSTD levels, but GMW can achieve better compression ratios with higher ZSTD levels.
Increasing the ZSTD level for GMW generally improved the compression ratio but increased the compression time, demonstrating a configurable trade-off.
All downloaded datasets and temporary files created during the process were successfully removed.
Insights or Next Steps
The GMW tool offers a favorable balance between compression speed and ratio compared to tar.gz, making it potentially suitable for scenarios where faster compression is prioritized over maximum compression.
Further analysis could involve testing a wider range of ZSTD levels for GMW to explore the full spectrum of speed/ratio trade-offs and comparing GMW against other fast compression algorithms like LZ4 or Snappy.
Clean up
Subtask:
Remove the downloaded datasets and any temporary files or directories created during the process.

import shutil
import os

# Remove the directory containing downloaded datasets
if 'dataset_dir' in globals() and os.path.exists(dataset_dir):
    shutil.rmtree(dataset_dir)
    print(f"Removed downloaded datasets directory: {dataset_dir}")

# Remove the temporary directory for prepared datasets
if 'temp_dataset_dir' in globals() and os.path.exists(temp_dataset_dir):
    shutil.rmtree(temp_dataset_dir)
    print(f"Removed temporary directory for prepared datasets: {temp_dataset_dir}")


Visualize results
Subtask:
Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset.

import matplotlib.pyplot as plt
import numpy as np

data_types = list(benchmark_results_comprehensive.keys())

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']

    # Extract method names, sizes, times, and calculate ratios
    method_names = ['Original']
    sizes_kb = [original_size / 1024]
    times_sec = [0] # Time for original is 0
    ratios = [1.0] # Ratio for original is 1.0

    for method, method_results in results.items():
        if method == 'original_size':
            continue
        method_names.append(method)
        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']
        sizes_kb.append(compressed_size / 1024)
        times_sec.append(compression_time)
        ratio = original_size / compressed_size if compressed_size > 0 else 0
        ratios.append(ratio)

    x = np.arange(len(method_names))  # the label locations

    # Create subplots for size and time
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # Plot Compression Size
    bars1 = ax1.bar(x, sizes_kb, label='Size (KB)')
    ax1.set_ylabel('Size (KB)')
    ax1.set_title(f'Compression Size by Method for {data_type.capitalize()} Data')
    ax1.set_xticks(x)
    ax1.set_xticklabels(method_names, rotation=45, ha="right")
    ax1.legend()

    # Add compression ratio labels to size plot
    def autolabel_ratio(bars, ratios):
        for bar, ratio in zip(bars, ratios):
            height = bar.get_height()
            ax1.annotate(f'{ratio:.2f}',
                         xy=(bar.get_x() + bar.get_width() / 2, height),
                         xytext=(0, 3),  # 3 points vertical offset
                         textcoords="offset points",
                         ha='center', va='bottom')

    autolabel_ratio(bars1, ratios)


    # Plot Compression Time
    bars2 = ax2.bar(x[1:], times_sec[1:], label='Time (seconds)', color='orange') # Exclude original (time 0)
    ax2.set_ylabel('Time (seconds)')
    ax2.set_title(f'Compression Time by Method for {data_type.capitalize()} Data')
    ax2.set_xticks(x)
    ax2.set_xticklabels(method_names, rotation=45, ha="right")
    ax2.legend()

    fig.tight_layout()
    plt.show()

print("\nVisualization complete.")

Analyze and present results
Subtask:
Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels.

print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---")

for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    original_size_kb = original_size / 1024

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    # Print results for each compression method/level
    for method, method_results in results.items():
        if method == 'original_size':
            continue # Skip original size entry

        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']

        compressed_size_kb = compressed_size / 1024
        compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')

        print(f"  {method}:")
        print(f"    Compressed Size: {compressed_size_kb:.2f} KB")
        print(f"    Compression Time: {compression_time:.4f} seconds")
        print(f"    Compression Ratio: {compression_ratio:.2f}")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of Compression Methods on Real-world Datasets:")

# Summarize performance across datasets and methods
summary_data = {}
data_types = list(benchmark_results_comprehensive.keys()) # Define data_types here
method_names_list = [] # To store method names in order for table headers

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']
    summary_data[data_type] = {}
    for method, method_results in results.items():
         if method == 'original_size':
            continue
         if method not in method_names_list:
             method_names_list.append(method)
         compressed_size = method_results['compressed_size']
         compression_time = method_results['compression_time']
         compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')
         summary_data[data_type][method] = {'ratio': compression_ratio, 'time': compression_time}

# Sort method names for consistent table order
method_names_list.sort() # Alphabetical sort or define a specific order if needed

# Print summary table (optional, but good for comparison)
print("\nCompression Ratio Summary:")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('ratio', float('nan')):.2f}" for method in method_names_list]
    print("\t".join(row))

print("\nCompression Time Summary (seconds):")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('time', float('nan')):.4f}" for method in method_names_list]
    print("\t".join(row))

print("\nKey Observations:")
# Analyze and print observations about size and time comparisons
gmw_zstd_levels_methods = [method for method in method_names_list if method.startswith('gmw_zstd_')]
standard_methods = [method for method in method_names_list if method.startswith('standard_')]

for data_type in data_types:
    print(f"\n- {data_type.capitalize()} Data:")
    dataset_summary = summary_data[data_type]

    # Compare GMW ZSTD levels
    print("  GMW (ZSTD Levels) Comparison:")
    gmw_zstd_levels_methods.sort(key=lambda x: int(x.split('_')[-1])) # Sort GMW methods by level
    for i in range(len(gmw_zstd_levels_methods) - 1):
        method1 = gmw_zstd_levels_methods[i]
        method2 = gmw_zstd_levels_methods[i+1]
        level1 = int(method1.split('_')[-1])
        level2 = int(method2.split('_')[-1])

        ratio1 = dataset_summary[method1]['ratio']
        ratio2 = dataset_summary[method2]['ratio']
        time1 = dataset_summary[method1]['time']
        time2 = dataset_summary[method2]['time']

        if ratio2 > ratio1:
            print(f"    ZSTD Level {level2} achieved better compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        elif ratio2 < ratio1:
             print(f"    ZSTD Level {level2} achieved worse compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} achieved similar compression ratio ({ratio2:.2f}).")

        if time2 < time1:
            print(f"    ZSTD Level {level2} was faster than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        elif time2 > time1:
             print(f"    ZSTD Level {level2} was slower than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} had similar compression times ({time2:.4f}s).")

    # Compare GMW (best ratio and fastest) vs. standard methods
    if gmw_zstd_levels_methods:
        best_gmw_ratio_method = max(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['ratio'])
        best_gmw_time_method = min(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['time'])

        print("  GMW vs. Standard Methods Comparison:")
        print(f"    Best GMW Ratio ({best_gmw_ratio_method}): Ratio {dataset_summary[best_gmw_ratio_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_ratio_method]['time']:.4f}s")
        print(f"    Fastest GMW ({best_gmw_time_method}): Ratio {dataset_summary[best_gmw_time_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_time_method]['time']:.4f}s")

        for std_method in standard_methods:
            if std_method in dataset_summary: # Check if standard method results exist for this dataset
                print(f"    {std_method}: Ratio {dataset_summary[std_method]['ratio']:.2f}, Time {dataset_summary[std_method]['time']:.4f}s")

                # Compare Best GMW Ratio vs. Standard
                if dataset_summary[best_gmw_ratio_method]['ratio'] > dataset_summary[std_method]['ratio']:
                     print(f"      Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}) is better than {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}).")
                elif dataset_summary[best_gmw_ratio_method]['ratio'] < dataset_summary[std_method]['ratio']:
                     print(f"      {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}) is better than Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}).")
                else:
                     print(f"      Best GMW and {std_method} achieved similar ratios ({dataset_summary[std_method]['ratio']:.2f}).")

                # Compare Fastest GMW Time vs. Standard
                if dataset_summary[best_gmw_time_method]['time'] < dataset_summary[std_method]['time']:
                     print(f"      Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s) is faster than {std_method} time ({dataset_summary[std_method]['time']:.4f}s).")
                elif dataset_summary[best_gmw_time_method]['time'] > dataset_summary[std_method]['time']:
                     print(f"      {std_method} time ({dataset_summary[std_method]['time']:.4f}s) is faster than Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s).")
                else:
                     print(f"      Fastest GMW and {std_method} had similar times ({dataset_summary[std_method]['time']:.4f}s).")
            else:
                print(f"    {std_method}: Results not available for this dataset.")


print("\nOverall Conclusion:")
print("The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz, tar.lz4, tar.snappy) were benchmarked on real-world datasets.")
print("GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.")
print("Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.")
print("Faster standard methods like tar.lz4 and tar.snappy are competitive with or faster than GMW at lower ZSTD levels, but GMW can achieve better compression ratios.")
print("The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.")

Analyze and present results
Subtask:
Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels.

Reasoning: Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels

print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---")

for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    original_size_kb = original_size / 1024

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    # Print results for each compression method/level
    for method, method_results in results.items():
        if method == 'original_size':
            continue # Skip original size entry

        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']

        compressed_size_kb = compressed_size / 1024
        compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')

        print(f"  {method}:")
        print(f"    Compressed Size: {compressed_size_kb:.2f} KB")
        print(f"    Compression Time: {compression_time:.4f} seconds")
        print(f"    Compression Ratio: {compression_ratio:.2f}")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of Compression Methods on Real-world Datasets:")

# Summarize performance across datasets and methods
summary_data = {}
data_types = list(benchmark_results_comprehensive.keys()) # Define data_types here
method_names_list = [] # To store method names in order for table headers

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']
    summary_data[data_type] = {}
    for method, method_results in results.items():
         if method == 'original_size':
            continue
         if method not in method_names_list:
             method_names_list.append(method)
         compressed_size = method_results['compressed_size']
         compression_time = method_results['compression_time']
         compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')
         summary_data[data_type][method] = {'ratio': compression_ratio, 'time': compression_time}

# Sort method names for consistent table order
method_names_list.sort() # Alphabetical sort or define a specific order if needed

# Print summary table (optional, but good for comparison)
print("\nCompression Ratio Summary:")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('ratio', float('nan')):.2f}" for method in method_names_list]
    print("\t".join(row))

print("\nCompression Time Summary (seconds):")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('time', float('nan')):.4f}" for method in method_names_list]
    print("\t".join(row))

print("\nKey Observations:")
# Analyze and print observations about size and time comparisons
gmw_zstd_levels_methods = [method for method in method_names_list if method.startswith('gmw_zstd_')]
standard_methods = [method for method in method_names_list if method.startswith('standard_')]

for data_type in data_types:
    print(f"\n- {data_type.capitalize()} Data:")
    dataset_summary = summary_data[data_type]

    # Compare GMW ZSTD levels
    print("  GMW (ZSTD Levels) Comparison:")
    gmw_zstd_levels_methods.sort(key=lambda x: int(x.split('_')[-1])) # Sort GMW methods by level
    for i in range(len(gmw_zstd_levels_methods) - 1):
        method1 = gmw_zstd_levels_methods[i]
        method2 = gmw_zstd_levels_methods[i+1]
        level1 = int(method1.split('_')[-1])
        level2 = int(method2.split('_')[-1])

        ratio1 = dataset_summary[method1]['ratio']
        ratio2 = dataset_summary[method2]['ratio']
        time1 = dataset_summary[method1]['time']
        time2 = dataset_summary[method2]['time']

        if ratio2 > ratio1:
            print(f"    ZSTD Level {level2} achieved better compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        elif ratio2 < ratio1:
             print(f"    ZSTD Level {level2} achieved worse compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} achieved similar compression ratio ({ratio2:.2f}).")

        if time2 < time1:
            print(f"    ZSTD Level {level2} was faster than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        elif time2 > time1:
             print(f"    ZSTD Level {level2} was slower than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} had similar compression times ({time2:.4f}s).")

    # Compare GMW (best ratio and fastest) vs. standard methods
    if gmw_zstd_levels_methods:
        best_gmw_ratio_method = max(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['ratio'])
        best_gmw_time_method = min(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['time'])

        print("  GMW vs. Standard Methods Comparison:")
        print(f"    Best GMW Ratio ({best_gmw_ratio_method}): Ratio {dataset_summary[best_gmw_ratio_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_ratio_method]['time']:.4f}s")
        print(f"    Fastest GMW ({best_gmw_time_method}): Ratio {dataset_summary[best_gmw_time_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_time_method]['time']:.4f}s")

        for std_method in standard_methods:
            if std_method in dataset_summary: # Check if standard method results exist for this dataset
                print(f"    {std_method}: Ratio {dataset_summary[std_method]['ratio']:.2f}, Time {dataset_summary[std_method]['time']:.4f}s")

                # Compare Best GMW Ratio vs. Standard
                if dataset_summary[best_gmw_ratio_method]['ratio'] > dataset_summary[std_method]['ratio']:
                     print(f"      Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}) is better than {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}).")
                elif dataset_summary[best_gmw_ratio_method]['ratio'] < dataset_summary[std_method]['ratio']:
                     print(f"      {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}) is better than Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}).")
                else:
                     print(f"      Best GMW and {std_method} achieved similar ratios ({dataset_summary[std_method]['ratio']:.2f}).")

                # Compare Fastest GMW Time vs. Standard
                if dataset_summary[best_gmw_time_method]['time'] < dataset_summary[std_method]['time']:
                     print(f"      Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s) is faster than {std_method} time ({dataset_summary[std_method]['time']:.4f}s).")
                elif dataset_summary[best_gmw_time_method]['time'] > dataset_summary[std_method]['time']:
                     print(f"      {std_method} time ({dataset_summary[std_method]['time']:.4f}s) is faster than Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s).")
                else:
                     print(f"      Fastest GMW and {std_method} had similar times ({dataset_summary[std_method]['time']:.4f}s).")
            else:
                print(f"    {std_method}: Results not available for this dataset.")


print("\nOverall Conclusion:")
print("The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz, tar.lz4, tar.snappy) were benchmarked on real-world datasets.")
print("GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.")
print("Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.")
print("Faster standard methods like tar.lz4 and tar.snappy are competitive with or faster than GMW at lower ZSTD levels, but GMW can achieve better compression ratios.")
print("The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression

- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---

Benchmarking Results for Text Data:
  Original Size: 1089.25 KB
  gmw_zstd_1:
    Compressed Size: 474.07 KB
    Compression Time: 0.0657 seconds
    Compression Ratio: 2.30
  gmw_zstd_3:
    Compressed Size: 420.02 KB
    Compression Time: 0.3253 seconds
    Compression Ratio: 2.59
  gmw_zstd_6:
    Compressed Size: 396.14 KB
    Compression Time: 0.5279 seconds
    Compression Ratio: 2.75
  gmw_zstd_9:
    Compressed Size: 388.08 KB
    Compression Time: 1.4283 seconds
    Compression Ratio: 2.81
  standard_tar_gz:
    Compressed Size: 424.05 KB
    Compression Time: 1.5086 seconds
    Compression Ratio: 2.57
  standard_tar_bz2:
    Compressed Size: 321.22 KB
    Compression Time: 1.9224 seconds
    Compression Ratio: 3.39
  standard_tar_xz:
    Compressed Size: 355.66 KB
    Compression Time: 13.1224 seconds
    Compression Ratio: 3.06
  standard_tar_lz4:
    Compressed Size: 697.86 KB
    Compression Time: 0.3671 seconds
    Compression Ratio: 1.56
  standard_tar_snappy:
    Compressed Size: 687.45 KB
    Compression Time: 0.0351 seconds
    Compression Ratio: 1.58

Benchmarking Results for Image Data:
  Original Size: 181849.72 KB
  gmw_zstd_1:
    Compressed Size: 176806.69 KB
    Compression Time: 3.0459 seconds
    Compression Ratio: 1.03
  gmw_zstd_3:
    Compressed Size: 169962.54 KB
    Compression Time: 4.5595 seconds
    Compression Ratio: 1.07
  gmw_zstd_6:
    Compressed Size: 170210.04 KB
    Compression Time: 6.6488 seconds
    Compression Ratio: 1.07
  gmw_zstd_9:
    Compressed Size: 167407.99 KB
    Compression Time: 8.0633 seconds
    Compression Ratio: 1.09
  standard_tar_gz:
    Compressed Size: 165992.59 KB
    Compression Time: 14.9550 seconds
    Compression Ratio: 1.10
  standard_tar_bz2:
    Compressed Size: 143644.64 KB
    Compression Time: 34.3465 seconds
    Compression Ratio: 1.27
  standard_tar_xz:
    Compressed Size: 136372.96 KB
    Compression Time: 157.5996 seconds
    Compression Ratio: 1.33
  standard_tar_lz4:
    Compressed Size: 176871.16 KB
    Compression Time: 7.9854 seconds
    Compression Ratio: 1.03
  standard_tar_snappy:
    Compressed Size: 180226.82 KB
    Compression Time: 2.8881 seconds
    Compression Ratio: 1.01

Benchmarking Results for Audio Data:
  Original Size: 308897.86 KB
  gmw_zstd_1:
    Compressed Size: 230257.74 KB
    Compression Time: 9.6255 seconds
    Compression Ratio: 1.34
  gmw_zstd_3:
    Compressed Size: 221394.69 KB
    Compression Time: 6.4887 seconds
    Compression Ratio: 1.40
  gmw_zstd_6:
    Compressed Size: 217374.03 KB
    Compression Time: 11.5138 seconds
    Compression Ratio: 1.42
  gmw_zstd_9:
    Compressed Size: 215016.38 KB
    Compression Time: 17.3191 seconds
    Compression Ratio: 1.44
  standard_tar_gz:
    Compressed Size: 231722.17 KB
    Compression Time: 47.4288 seconds
    Compression Ratio: 1.33
  standard_tar_bz2:
    Compressed Size: 194092.53 KB
    Compression Time: 54.5918 seconds
    Compression Ratio: 1.59
  standard_tar_xz:
    Compressed Size: 192048.54 KB
    Compression Time: 298.5293 seconds
    Compression Ratio: 1.61
  standard_tar_lz4:
    Compressed Size: 281221.62 KB
    Compression Time: 18.9359 seconds
    Compression Ratio: 1.10
  standard_tar_snappy:
    Compressed Size: 288454.67 KB
    Compression Time: 12.9499 seconds
    Compression Ratio: 1.07

Benchmarking Results for Structured Data:
  Original Size: 3881.16 KB
  gmw_zstd_1:
    Compressed Size: 530.20 KB
    Compression Time: 7.4283 seconds
    Compression Ratio: 7.32
  gmw_zstd_3:
    Compressed Size: 533.21 KB
    Compression Time: 0.0286 seconds
    Compression Ratio: 7.28
  gmw_zstd_6:
    Compressed Size: 428.74 KB
    Compression Time: 0.1091 seconds
    Compression Ratio: 9.05
  gmw_zstd_9:
    Compressed Size: 386.64 KB
    Compression Time: 0.2277 seconds
    Compression Ratio: 10.04
  standard_tar_gz:
    Compressed Size: 400.03 KB
    Compression Time: 0.5789 seconds
    Compression Ratio: 9.70
  standard_tar_bz2:
    Compressed Size: 230.36 KB
    Compression Time: 2.8696 seconds
    Compression Ratio: 16.85
  standard_tar_xz:
    Compressed Size: 305.94 KB
    Compression Time: 3.4629 seconds
    Compression Ratio: 12.69
  standard_tar_lz4:
    Compressed Size: 854.37 KB
    Compression Time: 0.1241 seconds
    Compression Ratio: 4.54
  standard_tar_snappy:
    Compressed Size: 893.85 KB
    Compression Time: 0.0215 seconds
    Compression Ratio: 4.34

--- Overall Summary ---
Comparison of Compression Methods on Real-world Datasets:

Compression Ratio Summary:
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	gmw_zstd_9	standard_tar_bz2	standard_tar_gz	standard_tar_lz4	standard_tar_snappy	standard_tar_xz
Text	2.30	2.59	2.75	2.81	3.39	2.57	1.56	1.58	3.06
Image	1.03	1.07	1.07	1.09	1.27	1.10	1.03	1.01	1.33
Audio	1.34	1.40	1.42	1.44	1.59	1.33	1.10	1.07	1.61
Structured	7.32	7.28	9.05	10.04	16.85	9.70	4.54	4.34	12.69

Compression Time Summary (seconds):
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	gmw_zstd_9	standard_tar_bz2	standard_tar_gz	standard_tar_lz4	standard_tar_snappy	standard_tar_xz
Text	0.0657	0.3253	0.5279	1.4283	1.9224	1.5086	0.3671	0.0351	13.1224
Image	3.0459	4.5595	6.6488	8.0633	34.3465	14.9550	7.9854	2.8881	157.5996
Audio	9.6255	6.4887	11.5138	17.3191	54.5918	47.4288	18.9359	12.9499	298.5293
Structured	7.4283	0.0286	0.1091	0.2277	2.8696	0.5789	0.1241	0.0215	3.4629

Key Observations:

- Text Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (2.59 vs 2.30).
    ZSTD Level 3 was slower than Level 1 (0.3253s vs 0.0657s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (2.75 vs 2.59).
    ZSTD Level 6 was slower than Level 3 (0.5279s vs 0.3253s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (2.81 vs 2.75).
    ZSTD Level 9 was slower than Level 6 (1.4283s vs 0.5279s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 2.81, Time 1.4283s
    Fastest GMW (gmw_zstd_1): Ratio 2.30, Time 0.0657s
    standard_tar_bz2: Ratio 3.39, Time 1.9224s
      standard_tar_bz2 ratio (3.39) is better than Best GMW ratio (2.81).
      Fastest GMW time (0.0657s) is faster than standard_tar_bz2 time (1.9224s).
    standard_tar_gz: Ratio 2.57, Time 1.5086s
      Best GMW ratio (2.81) is better than standard_tar_gz ratio (2.57).
      Fastest GMW time (0.0657s) is faster than standard_tar_gz time (1.5086s).
    standard_tar_lz4: Ratio 1.56, Time 0.3671s
      Best GMW ratio (2.81) is better than standard_tar_lz4 ratio (1.56).
      Fastest GMW time (0.0657s) is faster than standard_tar_lz4 time (0.3671s).
    standard_tar_snappy: Ratio 1.58, Time 0.0351s
      Best GMW ratio (2.81) is better than standard_tar_snappy ratio (1.58).
      standard_tar_snappy time (0.0351s) is faster than Fastest GMW time (0.0657s).
    standard_tar_xz: Ratio 3.06, Time 13.1224s
      standard_tar_xz ratio (3.06) is better than Best GMW ratio (2.81).
      Fastest GMW time (0.0657s) is faster than standard_tar_xz time (13.1224s).

- Image Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.07 vs 1.03).
    ZSTD Level 3 was slower than Level 1 (4.5595s vs 3.0459s).
    ZSTD Level 6 achieved worse compression ratio than Level 3 (1.07 vs 1.07).
    ZSTD Level 6 was slower than Level 3 (6.6488s vs 4.5595s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (1.09 vs 1.07).
    ZSTD Level 9 was slower than Level 6 (8.0633s vs 6.6488s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 1.09, Time 8.0633s
    Fastest GMW (gmw_zstd_1): Ratio 1.03, Time 3.0459s
    standard_tar_bz2: Ratio 1.27, Time 34.3465s
      standard_tar_bz2 ratio (1.27) is better than Best GMW ratio (1.09).
      Fastest GMW time (3.0459s) is faster than standard_tar_bz2 time (34.3465s).
    standard_tar_gz: Ratio 1.10, Time 14.9550s
      standard_tar_gz ratio (1.10) is better than Best GMW ratio (1.09).
      Fastest GMW time (3.0459s) is faster than standard_tar_gz time (14.9550s).
    standard_tar_lz4: Ratio 1.03, Time 7.9854s
      Best GMW ratio (1.09) is better than standard_tar_lz4 ratio (1.03).
      Fastest GMW time (3.0459s) is faster than standard_tar_lz4 time (7.9854s).
    standard_tar_snappy: Ratio 1.01, Time 2.8881s
      Best GMW ratio (1.09) is better than standard_tar_snappy ratio (1.01).
      standard_tar_snappy time (2.8881s) is faster than Fastest GMW time (3.0459s).
    standard_tar_xz: Ratio 1.33, Time 157.5996s
      standard_tar_xz ratio (1.33) is better than Best GMW ratio (1.09).
      Fastest GMW time (3.0459s) is faster than standard_tar_xz time (157.5996s).

- Audio Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.40 vs 1.34).
    ZSTD Level 3 was faster than Level 1 (6.4887s vs 9.6255s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (1.42 vs 1.40).
    ZSTD Level 6 was slower than Level 3 (11.5138s vs 6.4887s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (1.44 vs 1.42).
    ZSTD Level 9 was slower than Level 6 (17.3191s vs 11.5138s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 1.44, Time 17.3191s
    Fastest GMW (gmw_zstd_3): Ratio 1.40, Time 6.4887s
    standard_tar_bz2: Ratio 1.59, Time 54.5918s
      standard_tar_bz2 ratio (1.59) is better than Best GMW ratio (1.44).
      Fastest GMW time (6.4887s) is faster than standard_tar_bz2 time (54.5918s).
    standard_tar_gz: Ratio 1.33, Time 47.4288s
      Best GMW ratio (1.44) is better than standard_tar_gz ratio (1.33).
      Fastest GMW time (6.4887s) is faster than standard_tar_gz time (47.4288s).
    standard_tar_lz4: Ratio 1.10, Time 18.9359s
      Best GMW ratio (1.44) is better than standard_tar_lz4 ratio (1.10).
      Fastest GMW time (6.4887s) is faster than standard_tar_lz4 time (18.9359s).
    standard_tar_snappy: Ratio 1.07, Time 12.9499s
      Best GMW ratio (1.44) is better than standard_tar_snappy ratio (1.07).
      Fastest GMW time (6.4887s) is faster than standard_tar_snappy time (12.9499s).
    standard_tar_xz: Ratio 1.61, Time 298.5293s
      standard_tar_xz ratio (1.61) is better than Best GMW ratio (1.44).
      Fastest GMW time (6.4887s) is faster than standard_tar_xz time (298.5293s).

- Structured Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved worse compression ratio than Level 1 (7.28 vs 7.32).
    ZSTD Level 3 was faster than Level 1 (0.0286s vs 7.4283s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (9.05 vs 7.28).
    ZSTD Level 6 was slower than Level 3 (0.1091s vs 0.0286s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (10.04 vs 9.05).
    ZSTD Level 9 was slower than Level 6 (0.2277s vs 0.1091s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 10.04, Time 0.2277s
    Fastest GMW (gmw_zstd_3): Ratio 7.28, Time 0.0286s
    standard_tar_bz2: Ratio 16.85, Time 2.8696s
      standard_tar_bz2 ratio (16.85) is better than Best GMW ratio (10.04).
      Fastest GMW time (0.0286s) is faster than standard_tar_bz2 time (2.8696s).
    standard_tar_gz: Ratio 9.70, Time 0.5789s
      Best GMW ratio (10.04) is better than standard_tar_gz ratio (9.70).
      Fastest GMW time (0.0286s) is faster than standard_tar_gz time (0.5789s).
    standard_tar_lz4: Ratio 4.54, Time 0.1241s
      Best GMW ratio (10.04) is better than standard_tar_lz4 ratio (4.54).
      Fastest GMW time (0.0286s) is faster than standard_tar_lz4 time (0.1241s).
    standard_tar_snappy: Ratio 4.34, Time 0.0215s
      Best GMW ratio (10.04) is better than standard_tar_snappy ratio (4.34).
      standard_tar_snappy time (0.0215s) is faster than Fastest GMW time (0.0286s).
    standard_tar_xz: Ratio 12.69, Time 3.4629s
      standard_tar_xz ratio (12.69) is better than Best GMW ratio (10.04).
      Fastest GMW time (0.0286s) is faster than standard_tar_xz time (3.4629s).

Overall Conclusion:
The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz, tar.lz4, tar.snappy) were benchmarked on real-world datasets.
GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.
Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.
Faster standard methods like tar.lz4 and tar.snappy are competitive with or faster than GMW at lower ZSTD levels, but GMW can achieve better compression ratios.
The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.

Task
Benchmark the gmw_tool.py script with different ZSTD levels against standard compression methods (tar.gz, bz2, xz) using real-world datasets, skipping data generation, and visualize the results.

Identify and obtain real-world datasets
Subtask:
Find and download suitable real-world datasets of different types (e.g., a text corpus, an image dataset, audio samples, structured data).

Reasoning: Define the dataset information, create the download directory, and download the datasets.


import requests
import os

# Define dataset information
dataset_info = {
    'text': {
        'name': 'Tiny Shakespeare',
        'description': 'A small text corpus of Shakespeare\'s plays.',
        'source': 'Andrej Karpathy\'s repo',
        'url': 'https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt',
        'approx_size': '1 MB'
    },
    'image': {
        'name': 'CIFAR-10 (Subset)',
        'description': 'A subset of the CIFAR-10 dataset containing 10 classes of 32x32 color images.',
        'source': 'Kaggle or official website',
        'url': 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz',
        'approx_size': '170 MB (full dataset), we will use a subset'
    },
    'audio': {
        'name': 'Speech Commands Dataset (Subset)',
        'description': 'A subset of the Speech Commands dataset, containing short audio clips of spoken words.',
        'source': 'TensorFlow Datasets or Kaggle',
        'url': 'http://download.tensorflow.org/data/speech_commands_v0.02.tar.gz',
        'approx_size': '2.4 GB (full dataset), we will use a subset'
    },
    'structured': {
        'name': 'UCI Adult Income Dataset',
        'description': 'Contains demographic data from the 1994 Census Bureau database, used for predicting income.',
        'source': 'UCI Machine Learning Repository',
        'url': 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',
        'approx_size': '4 MB'
    }
}

# Create a directory to store the downloaded datasets
dataset_dir = 'real_world_datasets'
os.makedirs(dataset_dir, exist_ok=True)

# Download the datasets
for data_type, info in dataset_info.items():
    url = info['url']
    file_name = url.split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)

    if not os.path.exists(file_path):
        print(f"Downloading {info['name']}...")
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status() # Raise an exception for bad status codes
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"Downloaded {info['name']} to {file_path}")
        except requests.exceptions.RequestException as e:
            print(f"Error downloading {info['name']}: {e}")
            # Remove the incomplete file if download failed
            if os.path.exists(file_path):
                os.remove(file_path)
    else:
        print(f"{info['name']} already exists at {file_path}")

# Print the dataset information
print("\n--- Real-world Datasets for Benchmarking ---")
for data_type, info in dataset_info.items():
    print(f"\nDataset Type: {data_type.capitalize()}")
    print(f"  Name: {info['name']}")
    print(f"  Description: {info['description']}")
    print(f"  Source: {info['source']}")
    print(f"  URL: {info['url']}")
    print(f"  Approximate Size: {info['approx_size']}")
    # Add actual downloaded file path if successful
    file_name = info['url'].split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)
    if os.path.exists(file_path):
        print(f"  Downloaded Path: {file_path}")


      Prepare datasets for compression
Subtask:
Ensure the datasets are in a format that can be processed by the gmw_tool.py and standard compression methods. This might involve organizing files in directories or converting data formats if necessary.

Reasoning: I need to prepare the downloaded datasets for compression by creating a temporary directory, organizing the files into subdirectories based on data type, handling tar.gz extraction and subset selection for large datasets, and copying other file types. Then, I will store the paths to the prepared dataset directories and print them.


import os
import tempfile
import shutil
import tarfile
import requests # Re-import requests to ensure it's available if kernel restarts

# Define dataset information again to ensure it's available
dataset_info = {
    'text': {
        'name': 'Tiny Shakespeare',
        'description': 'A small text corpus of Shakespeare\'s plays.',
        'source': 'Andrej Karpathy\'s repo',
        'url': 'https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt',
        'approx_size': '1 MB'
    },
    'image': {
        'name': 'CIFAR-10 (Subset)',
        'description': 'A subset of the CIFAR-10 dataset containing 10 classes of 32x32 color images.',
        'source': 'Kaggle or official website',
        'url': 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz',
        'approx_size': '170 MB (full dataset), we will use a subset'
    },
    'audio': {
        'name': 'Speech Commands Dataset (Subset)',
        'description': 'A subset of the Speech Commands dataset, containing short audio clips of spoken words.',
        'source': 'TensorFlow Datasets or Kaggle',
        'url': 'http://download.tensorflow.org/data/speech_commands_v0.02.tar.gz',
        'approx_size': '2.4 GB (full dataset), we will use a subset'
    },
    'structured': {
        'name': 'UCI Adult Income Dataset',
        'description': 'Contains demographic data from the 1994 Census Bureau database, used for predicting income.',
        'source': 'UCI Machine Learning Repository',
        'url': 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',
        'approx_size': '4 MB'
    }
}

# Define dataset_dir here as it's used in this block
dataset_dir = 'real_world_datasets'
os.makedirs(dataset_dir, exist_ok=True)


# Create a temporary directory to prepare datasets
temp_dataset_dir = tempfile.mkdtemp()
print(f"Created temporary directory for datasets: {temp_dataset_dir}")

# Process each downloaded dataset
for data_type, info in dataset_info.items():
    file_name = info['url'].split('/')[-1]
    downloaded_file_path = os.path.join(dataset_dir, file_name)

    if os.path.exists(downloaded_file_path):
        # Create a subdirectory for the dataset type within the temporary directory
        dataset_subdir = os.path.join(temp_dataset_dir, data_type)
        os.makedirs(dataset_subdir, exist_ok=True)
        print(f"Created subdirectory: {dataset_subdir}")

        # Handle different file types and potential subsets
        if file_name.endswith('.tar.gz'):
            print(f"Extracting {file_name}...")
            try:
                with tarfile.open(downloaded_file_path, 'r:gz') as tar:
                    # Extract to the dataset-specific subdirectory
                    # Using filter='data' to mitigate CVE-2007-4559
                    tar.extractall(path=dataset_subdir, filter='data')
                print(f"Extracted {file_name} to {dataset_subdir}")

                # For large archives like CIFAR-10 and Speech Commands, select a subset
                if data_type in ['image', 'audio']:
                    print(f"Selecting a subset for {data_type} data...")
                    # List all extracted files and directories
                    extracted_items = [os.path.join(dataset_subdir, item) for item in os.listdir(dataset_subdir)]
                    extracted_files = [item for item in extracted_items if os.path.isfile(item)]
                    extracted_dirs = [item for item in extracted_items if os.path.isdir(item)]

                    items_to_keep = []
                    if data_type == 'image':
                        # CIFAR-10 files are typically batches like data_batch_1.bin, test_batch.bin
                        # Or extracted folders. Let's look for data files or subdirectories.
                        # We'll keep one data file or one representative subdirectory.
                        data_file = next((f for f in extracted_files if 'data_batch' in f or 'test_batch' in f), None)
                        if data_file:
                             items_to_keep.append(data_file)
                        else:
                             # If no batch files, look for directories (extracted from tar)
                             cifar_dirs = [d for d in extracted_dirs if 'cifar-10-batches-py' in d]
                             if cifar_dirs:
                                items_to_keep.append(cifar_dirs[0]) # Keep the first found directory
                             else:
                                # As a fallback, keep a few arbitrary files if structure is unexpected
                                items_to_keep.extend(extracted_files[:5])

                    elif data_type == 'audio':
                        # Speech Commands has subdirectories for each word. Keep a few words.
                        word_dirs = [d for d in extracted_dirs if os.path.basename(d) not in ['_background_noise_', 'LICENSE', 'README.md']]
                        items_to_keep.extend(word_dirs[:3]) # Keep first 3 word directories

                    # Remove everything else from the subdirectory
                    for item in extracted_items:
                        if item not in items_to_keep:
                            if os.path.isdir(item):
                                shutil.rmtree(item)
                            else:
                                os.remove(item)
                    print(f"Subset selected for {data_type}. Remaining items: {[os.path.basename(item) for item in items_to_keep]}")

            except tarfile.ReadError as e:
                 print(f"Error extracting {file_name}: {e}. This might not be a valid tar.gz file.")
                 # Clean up the partially created subdirectory
                 if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                 continue # Skip to the next dataset
            except Exception as e:
                print(f"An unexpected error occurred during extraction of {file_name}: {e}")
                if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                continue


        else:
            # For other file types (like .txt or .data), just copy the file
            shutil.copy(downloaded_file_path, dataset_subdir)
            print(f"Copied {file_name} to {dataset_subdir}")
    else:
        print(f"Downloaded file not found for {data_type} at {downloaded_file_path}")


# Store the paths to the prepared dataset directories
prepared_dataset_paths = {}
for data_type in dataset_info.keys():
    dataset_subdir = os.path.join(temp_dataset_dir, data_type)
    if os.path.exists(dataset_subdir) and os.listdir(dataset_subdir): # Check if directory exists and is not empty
         prepared_dataset_paths[data_type] = dataset_subdir
    else:
         print(f"Warning: No prepared data found for {data_type} in {dataset_subdir}")


print("\n--- Prepared Dataset Paths ---")
print(prepared_dataset_paths)

Identify additional compression algorithms
Subtask:
Determine which standard Python libraries or tools can be used for bz2 and xz compression.

Reasoning: Attempt to import the bz2 and lzma libraries to check if they are installed.

import bz2
import lzma

print(f"bz2 compression module: {bz2.__name__}")
print(f"xz compression module: {lzma.__name__}")

Benchmark compression with variations
Subtask:
For each real-world dataset, compress it using the gmw_tool.py script with different ZSTD levels, and also using standard methods (tar.gz, bz2, xz). Measure the compression size and time for all variations.

Reasoning: Iterate through each dataset, measure its original size, and then compress it using gmw_tool with different ZSTD levels, tar.gz, bz2, and xz, recording the size and time for each.


import time
import os
import tarfile
import zlib
import bz2
import lzma
import shutil

benchmark_results_comprehensive = {}
zstd_levels = [1, 3, 6] # ZSTD compression levels to test

for data_type, dataset_path in prepared_dataset_paths.items():
    print(f"\nBenchmarking real-world {data_type} data from {dataset_path}")

    # Measure original data size (size of the directory contents)
    original_size = sum(os.path.getsize(os.path.join(root, name)) for root, dirs, files in os.walk(dataset_path) for name in files)

    benchmark_results_comprehensive[data_type] = {'original_size': original_size}

    # Benchmark GMW compression with different ZSTD levels
    for level in zstd_levels:
        gmw_output_path = f"{dataset_path}.gmw_zstd{level}"
        gmw_start_time = time.time()
        compress_folder_to_gmw(dataset_path, gmw_output_path, use_zstd=True, zstd_level=level)
        gmw_end_time = time.time()
        gmw_compression_time = gmw_end_time - gmw_start_time
        gmw_compressed_size = os.path.getsize(gmw_output_path)

        benchmark_results_comprehensive[data_type][f'gmw_zstd_{level}'] = {
            'compressed_size': gmw_compressed_size,
            'compression_time': gmw_compression_time
        }
        print(f"  GMW (ZSTD level {level}) compressed size: {gmw_compressed_size} bytes")
        print(f"  GMW (ZSTD level {level}) compression time: {gmw_compression_time:.4f} seconds")


    # Benchmark standard compression (tar.gz)
    standard_gz_output_path = f"{dataset_path}.tar.gz"
    standard_gz_start_time = time.time()
    with open(standard_gz_output_path, 'wb') as out_f:
        with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
            tf.add(dataset_path, arcname='.')
    standard_gz_end_time = time.time()
    standard_gz_compression_time = standard_gz_end_time - standard_gz_start_time
    standard_gz_compressed_size = os.path.getsize(standard_gz_output_path)

    benchmark_results_comprehensive[data_type]['standard_tar_gz'] = {
        'compressed_size': standard_gz_compressed_size,
        'compression_time': standard_gz_compression_time
    }
    print(f"  Standard (tar.gz) compressed size: {standard_gz_compressed_size} bytes")
    print(f"  Standard (tar.gz) compression time: {standard_gz_compression_time:.4f} seconds")

    # Benchmark standard compression (bz2)
    standard_bz2_output_path = f"{dataset_path}.tar.bz2"
    intermediate_tar_path_bz2 = f"{dataset_path}_bz2.tar" # Use different intermediate name
    standard_bz2_start_time = time.time()
    with tarfile.open(intermediate_tar_path_bz2, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_bz2, 'rb') as tar_in, open(standard_bz2_output_path, 'wb') as bz2_out:
        compressed_data = bz2.compress(tar_in.read())
        bz2_out.write(compressed_data) # Write the bytes directly
    standard_bz2_end_time = time.time()
    standard_bz2_compression_time = standard_bz2_end_time - standard_bz2_start_time
    standard_bz2_compressed_size = os.path.getsize(standard_bz2_output_path)
    os.remove(intermediate_tar_path_bz2) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_bz2'] = {
        'compressed_size': standard_bz2_compressed_size,
        'compression_time': standard_bz2_compression_time
    }
    print(f"  Standard (tar.bz2) compressed size: {standard_bz2_compressed_size} bytes")
    print(f"  Standard (tar.bz2) compression time: {standard_bz2_compression_time:.4f} seconds")

    # Benchmark standard compression (xz)
    standard_xz_output_path = f"{dataset_path}.tar.xz"
    intermediate_tar_path_xz = f"{dataset_path}_xz.tar" # Use different intermediate name
    standard_xz_start_time = time.time()
    with tarfile.open(intermediate_tar_path_xz, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_xz, 'rb') as tar_in, open(standard_xz_output_path, 'wb') as xz_out:
        compressed_data = lzma.compress(tar_in.read())
        xz_out.write(compressed_data) # Write the bytes directly
    standard_xz_end_time = time.time()
    standard_xz_compression_time = standard_xz_end_time - standard_xz_start_time
    standard_xz_compressed_size = os.path.getsize(standard_xz_output_path)
    os.remove(intermediate_tar_path_xz) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_xz'] = {
        'compressed_size': standard_xz_compressed_size,
        'compression_time': standard_xz_compression_time
    }
    print(f"  Standard (tar.xz) compressed size: {standard_xz_compressed_size} bytes")
    print(f"  Standard (tar.xz) compression time: {standard_xz_compression_time:.4f} seconds")


# Print the collected results
print("\n--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels) ---")
import json
print(json.dumps(benchmark_results_comprehensive, indent=2))

# Clean up all generated compressed files
print("\nCleaning up generated compressed files...")
for data_type, results in benchmark_results_comprehensive.items():
    dataset_path = prepared_dataset_paths[data_type]
    for key in results:
        if key.startswith('gmw_zstd_'):
            level = key.split('_')[-1]
            compressed_file = f"{dataset_path}.gmw_zstd{level}"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_gz':
            compressed_file = f"{dataset_path}.tar.gz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_bz2':
            compressed_file = f"{dataset_path}.tar.bz2"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_xz':
            compressed_file = f"{dataset_path}.tar.xz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")

               import time
import os
import tarfile
import zlib
import bz2
import lzma
import shutil

benchmark_results_comprehensive = {}
zstd_levels = [1, 3, 6] # ZSTD compression levels to test

for data_type, dataset_path in prepared_dataset_paths.items():
    print(f"\nBenchmarking real-world {data_type} data from {dataset_path}")

    # Measure original data size (size of the directory contents)
    original_size = sum(os.path.getsize(os.path.join(root, name)) for root, dirs, files in os.walk(dataset_path) for name in files)

    benchmark_results_comprehensive[data_type] = {'original_size': original_size}

    # Benchmark GMW compression with different ZSTD levels
    for level in zstd_levels:
        gmw_output_path = f"{dataset_path}.gmw_zstd{level}"
        gmw_start_time = time.time()
        compress_folder_to_gmw(dataset_path, gmw_output_path, use_zstd=True, zstd_level=level)
        gmw_end_time = time.time()
        gmw_compression_time = gmw_end_time - gmw_start_time
        gmw_compressed_size = os.path.getsize(gmw_output_path)

        benchmark_results_comprehensive[data_type][f'gmw_zstd_{level}'] = {
            'compressed_size': gmw_compressed_size,
            'compression_time': gmw_compression_time
        }
        print(f"  GMW (ZSTD level {level}) compressed size: {gmw_compressed_size} bytes")
        print(f"  GMW (ZSTD level {level}) compression time: {gmw_compression_time:.4f} seconds")


    # Benchmark standard compression (tar.gz)
    standard_gz_output_path = f"{dataset_path}.tar.gz"
    standard_gz_start_time = time.time()
    with open(standard_gz_output_path, 'wb') as out_f:
        with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
            tf.add(dataset_path, arcname='.')
    standard_gz_end_time = time.time()
    standard_gz_compression_time = standard_gz_end_time - standard_gz_start_time
    standard_gz_compressed_size = os.path.getsize(standard_gz_output_path)

    benchmark_results_comprehensive[data_type]['standard_tar_gz'] = {
        'compressed_size': standard_gz_compressed_size,
        'compression_time': standard_gz_compression_time
    }
    print(f"  Standard (tar.gz) compressed size: {standard_gz_compressed_size} bytes")
    print(f"  Standard (tar.gz) compression time: {standard_gz_compression_time:.4f} seconds")

    # Benchmark standard compression (bz2)
    standard_bz2_output_path = f"{dataset_path}.tar.bz2"
    intermediate_tar_path_bz2 = f"{dataset_path}_bz2.tar" # Use different intermediate name
    standard_bz2_start_time = time.time()
    with tarfile.open(intermediate_tar_path_bz2, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_bz2, 'rb') as tar_in, open(standard_bz2_output_path, 'wb') as bz2_out:
        compressed_data = bz2.compress(tar_in.read())
        bz2_out.write(compressed_data) # Write the bytes directly
    standard_bz2_end_time = time.time()
    standard_bz2_compression_time = standard_bz2_end_time - standard_bz2_start_time
    standard_bz2_compressed_size = os.path.getsize(standard_bz2_output_path)
    os.remove(intermediate_tar_path_bz2) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_bz2'] = {
        'compressed_size': standard_bz2_compressed_size,
        'compression_time': standard_bz2_compression_time
    }
    print(f"  Standard (tar.bz2) compressed size: {standard_bz2_compressed_size} bytes")
    print(f"  Standard (tar.bz2) compression time: {standard_bz2_compression_time:.4f} seconds")

    # Benchmark standard compression (xz)
    standard_xz_output_path = f"{dataset_path}.tar.xz"
    intermediate_tar_path_xz = f"{dataset_path}_xz.tar" # Use different intermediate name
    standard_xz_start_time = time.time()
    with tarfile.open(intermediate_tar_path_xz, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_xz, 'rb') as tar_in, open(standard_xz_output_path, 'wb') as xz_out:
        compressed_data = lzma.compress(tar_in.read())
        xz_out.write(compressed_data) # Write the bytes directly
    standard_xz_end_time = time.time()
    standard_xz_compression_time = standard_xz_end_time - standard_xz_start_time
    standard_xz_compressed_size = os.path.getsize(standard_xz_output_path)
    os.remove(intermediate_tar_path_xz) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_xz'] = {
        'compressed_size': standard_xz_compressed_size,
        'compression_time': standard_xz_compression_time
    }
    print(f"  Standard (tar.xz) compressed size: {standard_xz_compressed_size} bytes")
    print(f"  Standard (tar.xz) compression time: {standard_xz_compression_time:.4f} seconds")


# Print the collected results
print("\n--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels) ---")
import json
print(json.dumps(benchmark_results_comprehensive, indent=2))

# Clean up all generated compressed files
print("\nCleaning up generated compressed files...")
for data_type, results in benchmark_results_comprehensive.items():
    dataset_path = prepared_dataset_paths[data_type]
    for key in results:
        if key.startswith('gmw_zstd_'):
            level = key.split('_')[-1]
            compressed_file = f"{dataset_path}.gmw_zstd{level}"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_gz':
            compressed_file = f"{dataset_path}.tar.gz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_bz2':
            compressed_file = f"{dataset_path}.tar.bz2"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_xz':
            compressed_file = f"{dataset_path}.tar.xz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")

print("Cleanup complete.") 


Benchmarking real-world text data from /tmp/tmpk90dukwg/text
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 126.00file/s]
  GMW (ZSTD level 1) compressed size: 485545 bytes
  GMW (ZSTD level 1) compression time: 0.0667 seconds
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 336.41file/s]
  GMW (ZSTD level 3) compressed size: 430187 bytes
  GMW (ZSTD level 3) compression time: 0.0234 seconds
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 346.72file/s]  GMW (ZSTD level 6) compressed size: 405744 bytes
  GMW (ZSTD level 6) compression time: 0.0402 seconds

  Standard (tar.gz) compressed size: 434238 bytes
  Standard (tar.gz) compression time: 0.1213 seconds
  Standard (tar.bz2) compressed size: 328813 bytes
  Standard (tar.bz2) compression time: 0.1365 seconds
  Standard (tar.xz) compressed size: 364260 bytes
  Standard (tar.xz) compression time: 0.6535 seconds

Benchmarking real-world image data from /tmp/tmpk90dukwg/image
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 41.15file/s]
  GMW (ZSTD level 1) compressed size: 181052579 bytes
  GMW (ZSTD level 1) compression time: 1.3359 seconds
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 43.47file/s]
  GMW (ZSTD level 3) compressed size: 174075230 bytes
  GMW (ZSTD level 3) compression time: 5.4183 seconds
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 49.06file/s]
  GMW (ZSTD level 6) compressed size: 174305834 bytes
  GMW (ZSTD level 6) compression time: 4.1428 seconds
  Standard (tar.gz) compressed size: 169976395 bytes
  Standard (tar.gz) compression time: 11.4350 seconds
  Standard (tar.bz2) compressed size: 147091588 bytes
  Standard (tar.bz2) compression time: 23.6026 seconds
  Standard (tar.xz) compressed size: 139648908 bytes
  Standard (tar.xz) compression time: 124.6508 seconds

Benchmarking real-world audio data from /tmp/tmpk90dukwg/audio
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:03<00:00, 3007.48file/s]
  GMW (ZSTD level 1) compressed size: 241117624 bytes
  GMW (ZSTD level 1) compression time: 5.5058 seconds
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:03<00:00, 2728.05file/s]
  GMW (ZSTD level 3) compressed size: 231433649 bytes
  GMW (ZSTD level 3) compression time: 8.0901 seconds
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:03<00:00, 3228.24file/s]
  GMW (ZSTD level 6) compressed size: 227055526 bytes
  GMW (ZSTD level 6) compression time: 11.7302 seconds
  Standard (tar.gz) compressed size: 237283483 bytes
  Standard (tar.gz) compression time: 37.2118 seconds
  Standard (tar.bz2) compressed size: 198750725 bytes
  Standard (tar.bz2) compression time: 42.8201 seconds
  Standard (tar.xz) compressed size: 196659604 bytes
  Standard (tar.xz) compression time: 230.9390 seconds

Benchmarking real-world structured data from /tmp/tmpk90dukwg/structured
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 75.48file/s]
  GMW (ZSTD level 1) compressed size: 543072 bytes
  GMW (ZSTD level 1) compression time: 0.0323 seconds
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 185.25file/s]
  GMW (ZSTD level 3) compressed size: 546137 bytes
  GMW (ZSTD level 3) compression time: 0.0292 seconds
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 169.69file/s]  GMW (ZSTD level 6) compressed size: 438872 bytes
  GMW (ZSTD level 6) compression time: 0.0687 seconds

  Standard (tar.gz) compressed size: 409623 bytes
  Standard (tar.gz) compression time: 0.2596 seconds
  Standard (tar.bz2) compressed size: 235896 bytes
  Standard (tar.bz2) compression time: 0.8806 seconds
  Standard (tar.xz) compressed size: 313248 bytes
  Standard (tar.xz) compression time: 1.7244 seconds

--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels) ---
{
  "text": {
    "original_size": 1115394,
    "gmw_zstd_1": {
      "compressed_size": 485545,
      "compression_time": 0.06665897369384766
    },
    "gmw_zstd_3": {
      "compressed_size": 430187,
      "compression_time": 0.023364543914794922
    },
    "gmw_zstd_6": {
      "compressed_size": 405744,
      "compression_time": 0.04016280174255371
    },
    "standard_tar_gz": {
      "compressed_size": 434238,
      "compression_time": 0.12128400802612305
    },
    "standard_tar_bz2": {
      "compressed_size": 328813,
      "compression_time": 0.1365048885345459
    },
    "standard_tar_xz": {
      "compressed_size": 364260,
      "compression_time": 0.6535303592681885
    }
  },
  "image": {
    "original_size": 186214114,
    "gmw_zstd_1": {
      "compressed_size": 181052579,
      "compression_time": 1.3358962535858154
    },
    "gmw_zstd_3": {
      "compressed_size": 174075230,
      "compression_time": 5.418348550796509
    },
    "gmw_zstd_6": {
      "compressed_size": 174305834,
      "compression_time": 4.142810821533203
    },
    "standard_tar_gz": {
      "compressed_size": 169976395,
      "compression_time": 11.435027599334717
    },
    "standard_tar_bz2": {
      "compressed_size": 147091588,
      "compression_time": 23.60258150100708
    },
    "standard_tar_xz": {
      "compressed_size": 139648908,
      "compression_time": 124.65078926086426
    }
  },
  "audio": {
    "original_size": 316311406,
    "gmw_zstd_1": {
      "compressed_size": 241117624,
      "compression_time": 5.505766153335571
    },
    "gmw_zstd_3": {
      "compressed_size": 231433649,
      "compression_time": 8.090100526809692
    },
    "gmw_zstd_6": {
      "compressed_size": 227055526,
      "compression_time": 11.730154037475586
    },
    "standard_tar_gz": {
      "compressed_size": 237283483,
      "compression_time": 37.211819887161255
    },
    "standard_tar_bz2": {
      "compressed_size": 198750725,
      "compression_time": 42.82010269165039
    },
    "standard_tar_xz": {
      "compressed_size": 196659604,
      "compression_time": 230.93900680541992
    }
  },
  "structured": {
    "original_size": 3974305,
    "gmw_zstd_1": {
      "compressed_size": 543072,
      "compression_time": 0.032262325286865234
    },
    "gmw_zstd_3": {
      "compressed_size": 546137,
      "compression_time": 0.029230594635009766
    },
    "gmw_zstd_6": {
      "compressed_size": 438872,
      "compression_time": 0.06869053840637207
    },
    "standard_tar_gz": {
      "compressed_size": 409623,
      "compression_time": 0.25960636138916016
    },
    "standard_tar_bz2": {
      "compressed_size": 235896,
      "compression_time": 0.880591869354248
    },
    "standard_tar_xz": {
      "compressed_size": 313248,
      "compression_time": 1.7243881225585938
    }
  }
}

Cleaning up generated compressed files...
Removed /tmp/tmpk90dukwg/text.gmw_zstd1
Removed /tmp/tmpk90dukwg/text.gmw_zstd3
Removed /tmp/tmpk90dukwg/text.gmw_zstd6
Removed /tmp/tmpk90dukwg/text.tar.gz
Removed /tmp/tmpk90dukwg/text.tar.bz2
Removed /tmp/tmpk90dukwg/text.tar.xz
Removed /tmp/tmpk90dukwg/image.gmw_zstd1
Removed /tmp/tmpk90dukwg/image.gmw_zstd3
Removed /tmp/tmpk90dukwg/image.gmw_zstd6
Removed /tmp/tmpk90dukwg/image.tar.gz
Removed /tmp/tmpk90dukwg/image.tar.bz2
Removed /tmp/tmpk90dukwg/image.tar.xz
Removed /tmp/tmpk90dukwg/audio.gmw_zstd1
Removed /tmp/tmpk90dukwg/audio.gmw_zstd3
Removed /tmp/tmpk90dukwg/audio.gmw_zstd6
Removed /tmp/tmpk90dukwg/audio.tar.gz
Removed /tmp/tmpk90dukwg/audio.tar.bz2
Removed /tmp/tmpk90dukwg/audio.tar.xz
Removed /tmp/tmpk90dukwg/structured.gmw_zstd1
Removed /tmp/tmpk90dukwg/structured.gmw_zstd3
Removed /tmp/tmpk90dukwg/structured.gmw_zstd6
Removed /tmp/tmpk90dukwg/structured.tar.gz
Removed /tmp/tmpk90dukwg/structured.tar.bz2
Removed /tmp/tmpk90dukwg/structured.tar.xz
Cleanup complete



Visualize results
Subtask:
Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset.

Reasoning: Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset.

import matplotlib.pyplot as plt
import numpy as np

data_types = list(benchmark_results_comprehensive.keys())

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']

    # Extract method names, sizes, times, and calculate ratios
    method_names = ['Original']
    sizes_kb = [original_size / 1024]
    times_sec = [0] # Time for original is 0
    ratios = [1.0] # Ratio for original is 1.0

    for method, method_results in results.items():
        if method == 'original_size':
            continue
        method_names.append(method)
        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']
        sizes_kb.append(compressed_size / 1024)
        times_sec.append(compression_time)
        ratio = original_size / compressed_size if compressed_size > 0 else 0
        ratios.append(ratio)

    x = np.arange(len(method_names))  # the label locations

    # Create subplots for size and time
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # Plot Compression Size
    bars1 = ax1.bar(x, sizes_kb, label='Size (KB)')
    ax1.set_ylabel('Size (KB)')
    ax1.set_title(f'Compression Size by Method for {data_type.capitalize()} Data')
    ax1.set_xticks(x)
    ax1.set_xticklabels(method_names, rotation=45, ha="right")
    ax1.legend()

    # Add compression ratio labels to size plot
    def autolabel_ratio(bars, ratios):
        for bar, ratio in zip(bars, ratios):
            height = bar.get_height()
            ax1.annotate(f'{ratio:.2f}',
                         xy=(bar.get_x() + bar.get_width() / 2, height),
                         xytext=(0, 3),  # 3 points vertical offset
                         textcoords="offset points",
                         ha='center', va='bottom')

    autolabel_ratio(bars1, ratios)


    # Plot Compression Time
    bars2 = ax2.bar(x[1:], times_sec[1:], label='Time (seconds)', color='orange') # Exclude original (time 0)
    ax2.set_ylabel('Time (seconds)')
    ax2.set_title(f'Compression Time by Method for {data_type.capitalize()} Data')
    ax2.set_xticks(x)
    ax2.set_xticklabels(method_names, rotation=45, ha="right")
    ax2.legend()

    fig.tight_layout()
    plt.show()

print("\nVisualization complete.")

Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels.

print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels) ---")

for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    original_size_kb = original_size / 1024

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    # Print results for each compression method/level
    for method, method_results in results.items():
        if method == 'original_size':
            continue # Skip original size entry

        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']

        compressed_size_kb = compressed_size / 1024
        compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')

        print(f"  {method}:")
        print(f"    Compressed Size: {compressed_size_kb:.2f} KB")
        print(f"    Compression Time: {compression_time:.4f} seconds")
        print(f"    Compression Ratio: {compression_ratio:.2f}")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of Compression Methods on Real-world Datasets:")

# Summarize performance across datasets and methods
summary_data = {}
data_types = list(benchmark_results_comprehensive.keys()) # Define data_types here
method_names_list = [] # To store method names in order for table headers

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']
    summary_data[data_type] = {}
    for method, method_results in results.items():
         if method == 'original_size':
            continue
         if method not in method_names_list:
             method_names_list.append(method)
         compressed_size = method_results['compressed_size']
         compression_time = method_results['compression_time']
         compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')
         summary_data[data_type][method] = {'ratio': compression_ratio, 'time': compression_time}

# Sort method names for consistent table order
method_names_list.sort() # Alphabetical sort or define a specific order if needed

# Print summary table (optional, but good for comparison)
print("\nCompression Ratio Summary:")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('ratio', float('nan')):.2f}" for method in method_names_list]
    print("\t".join(row))

print("\nCompression Time Summary (seconds):")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('time', float('nan')):.4f}" for method in method_names_list]
    print("\t".join(row))

print("\nKey Observations:")
# Analyze and print observations about size and time comparisons
gmw_zstd_levels_methods = [method for method in method_names_list if method.startswith('gmw_zstd_')]
standard_methods = [method for method in method_names_list if method.startswith('standard_')]

for data_type in data_types:
    print(f"\n- {data_type.capitalize()} Data:")
    dataset_summary = summary_data[data_type]

    # Compare GMW ZSTD levels
    print("  GMW (ZSTD Levels) Comparison:")
    gmw_zstd_levels_methods.sort(key=lambda x: int(x.split('_')[-1])) # Sort GMW methods by level
    for i in range(len(gmw_zstd_levels_methods) - 1):
        method1 = gmw_zstd_levels_methods[i]
        method2 = gmw_zstd_levels_methods[i+1]
        level1 = int(method1.split('_')[-1])
        level2 = int(method2.split('_')[-1])

        ratio1 = dataset_summary[method1]['ratio']
        ratio2 = dataset_summary[method2]['ratio']
        time1 = dataset_summary[method1]['time']
        time2 = dataset_summary[method2]['time']

        if ratio2 > ratio1:
            print(f"    ZSTD Level {level2} achieved better compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        elif ratio2 < ratio1:
             print(f"    ZSTD Level {level2} achieved worse compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} achieved similar compression ratio ({ratio2:.2f}).")

        if time2 < time1:
            print(f"    ZSTD Level {level2} was faster than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        elif time2 > time1:
             print(f"    ZSTD Level {level2} was slower than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} had similar compression times ({time2:.4f}s).")

    # Compare GMW (best ratio and fastest) vs. standard methods
    if gmw_zstd_levels_methods:
        best_gmw_ratio_method = max(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['ratio'])
        best_gmw_time_method = min(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['time'])

        print("  GMW vs. Standard Methods Comparison:")
        print(f"    Best GMW Ratio ({best_gmw_ratio_method}): Ratio {dataset_summary[best_gmw_ratio_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_ratio_method]['time']:.4f}s")
        print(f"    Fastest GMW ({best_gmw_time_method}): Ratio {dataset_summary[best_gmw_time_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_time_method]['time']:.4f}s")

        for std_method in standard_methods:
            if std_method in dataset_summary: # Check if standard method results exist for this dataset
                print(f"    {std_method}: Ratio {dataset_summary[std_method]['ratio']:.2f}, Time {dataset_summary[std_method]['time']:.4f}s")

                # Compare Best GMW Ratio vs. Standard
                if dataset_summary[best_gmw_ratio_method]['ratio'] > dataset_summary[std_method]['ratio']:
                     print(f"      Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}) is better than {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}).")
                elif dataset_summary[best_gmw_ratio_method]['ratio'] < dataset_summary[std_method]['ratio']:
                     print(f"      {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}) is better than Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}).")
                else:
                     print(f"      Best GMW and {std_method} achieved similar ratios ({dataset_summary[std_method]['ratio']:.2f}).")

                # Compare Fastest GMW Time vs. Standard
                if dataset_summary[best_gmw_time_method]['time'] < dataset_summary[std_method]['time']:
                     print(f"      Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s) is faster than {std_method} time ({dataset_summary[std_method]['time']:.4f}s).")
                elif dataset_summary[best_gmw_time_method]['time'] > dataset_summary[std_method]['time']:
                     print(f"      {std_method} time ({dataset_summary[std_method]['time']:.4f}s) is faster than Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s).")
                else:
                     print(f"      Fastest GMW and {std_method} had similar times ({dataset_summary[std_method]['time']:.4f}s).")
            else:
                print(f"    {std_method}: Results not available for this dataset.")


print("\nOverall Conclusion:")
print("The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.")
print("GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.")
print("Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.")
print("The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.")

--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels) ---

Benchmarking Results for Text Data:
  Original Size: 1089.25 KB
  gmw_zstd_1:
    Compressed Size: 474.17 KB
    Compression Time: 0.0667 seconds
    Compression Ratio: 2.30
  gmw_zstd_3:
    Compressed Size: 420.10 KB
    Compression Time: 0.0234 seconds
    Compression Ratio: 2.59
  gmw_zstd_6:
    Compressed Size: 396.23 KB
    Compression Time: 0.0402 seconds
    Compression Ratio: 2.75
  standard_tar_gz:
    Compressed Size: 424.06 KB
    Compression Time: 0.1213 seconds
    Compression Ratio: 2.57
  standard_tar_bz2:
    Compressed Size: 321.11 KB
    Compression Time: 0.1365 seconds
    Compression Ratio: 3.39
  standard_tar_xz:
    Compressed Size: 355.72 KB
    Compression Time: 0.6535 seconds
    Compression Ratio: 3.06

Benchmarking Results for Image Data:
  Original Size: 181849.72 KB
  gmw_zstd_1:
    Compressed Size: 176809.16 KB
    Compression Time: 1.3359 seconds
    Compression Ratio: 1.03
  gmw_zstd_3:
    Compressed Size: 169995.34 KB
    Compression Time: 5.4183 seconds
    Compression Ratio: 1.07
  gmw_zstd_6:
    Compressed Size: 170220.54 KB
    Compression Time: 4.1428 seconds
    Compression Ratio: 1.07
  standard_tar_gz:
    Compressed Size: 165992.57 KB
    Compression Time: 11.4350 seconds
    Compression Ratio: 1.10
  standard_tar_bz2:
    Compressed Size: 143644.13 KB
    Compression Time: 23.6026 seconds
    Compression Ratio: 1.27
  standard_tar_xz:
    Compressed Size: 136375.89 KB
    Compression Time: 124.6508 seconds
    Compression Ratio: 1.33

Benchmarking Results for Audio Data:
  Original Size: 308897.86 KB
  gmw_zstd_1:
    Compressed Size: 235466.43 KB
    Compression Time: 5.5058 seconds
    Compression Ratio: 1.31
  gmw_zstd_3:
    Compressed Size: 226009.42 KB
    Compression Time: 8.0901 seconds
    Compression Ratio: 1.37
  gmw_zstd_6:
    Compressed Size: 221733.91 KB
    Compression Time: 11.7302 seconds
    Compression Ratio: 1.39
  standard_tar_gz:
    Compressed Size: 231722.15 KB
    Compression Time: 37.2118 seconds
    Compression Ratio: 1.33
  standard_tar_bz2:
    Compressed Size: 194092.50 KB
    Compression Time: 42.8201 seconds
    Compression Ratio: 1.59
  standard_tar_xz:
    Compressed Size: 192050.39 KB
    Compression Time: 230.9390 seconds
    Compression Ratio: 1.61

Benchmarking Results for Structured Data:
  Original Size: 3881.16 KB
  gmw_zstd_1:
    Compressed Size: 530.34 KB
    Compression Time: 0.0323 seconds
    Compression Ratio: 7.32
  gmw_zstd_3:
    Compressed Size: 533.34 KB
    Compression Time: 0.0292 seconds
    Compression Ratio: 7.28
  gmw_zstd_6:
    Compressed Size: 428.59 KB
    Compression Time: 0.0687 seconds
    Compression Ratio: 9.06
  standard_tar_gz:
    Compressed Size: 400.02 KB
    Compression Time: 0.2596 seconds
    Compression Ratio: 9.70
  standard_tar_bz2:
    Compressed Size: 230.37 KB
    Compression Time: 0.8806 seconds
    Compression Ratio: 16.85
  standard_tar_xz:
    Compressed Size: 305.91 KB
    Compression Time: 1.7244 seconds
    Compression Ratio: 12.69

--- Overall Summary ---
Comparison of Compression Methods on Real-world Datasets:

Compression Ratio Summary:
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	standard_tar_bz2	standard_tar_gz	standard_tar_xz
Text	2.30	2.59	2.75	3.39	2.57	3.06
Image	1.03	1.07	1.07	1.27	1.10	1.33
Audio	1.31	1.37	1.39	1.59	1.33	1.61
Structured	7.32	7.28	9.06	16.85	9.70	12.69

Compression Time Summary (seconds):
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	standard_tar_bz2	standard_tar_gz	standard_tar_xz
Text	0.0667	0.0234	0.0402	0.1365	0.1213	0.6535
Image	1.3359	5.4183	4.1428	23.6026	11.4350	124.6508
Audio	5.5058	8.0901	11.7302	42.8201	37.2118	230.9390
Structured	0.0323	0.0292	0.0687	0.8806	0.2596	1.7244

Key Observations:

- Text Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (2.59 vs 2.30).
    ZSTD Level 3 was faster than Level 1 (0.0234s vs 0.0667s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (2.75 vs 2.59).
    ZSTD Level 6 was slower than Level 3 (0.0402s vs 0.0234s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_6): Ratio 2.75, Time 0.0402s
    Fastest GMW (gmw_zstd_3): Ratio 2.59, Time 0.0234s
    standard_tar_bz2: Ratio 3.39, Time 0.1365s
      standard_tar_bz2 ratio (3.39) is better than Best GMW ratio (2.75).
      Fastest GMW time (0.0234s) is faster than standard_tar_bz2 time (0.1365s).
    standard_tar_gz: Ratio 2.57, Time 0.1213s
      Best GMW ratio (2.75) is better than standard_tar_gz ratio (2.57).
      Fastest GMW time (0.0234s) is faster than standard_tar_gz time (0.1213s).
    standard_tar_xz: Ratio 3.06, Time 0.6535s
      standard_tar_xz ratio (3.06) is better than Best GMW ratio (2.75).
      Fastest GMW time (0.0234s) is faster than standard_tar_xz time (0.6535s).

- Image Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.07 vs 1.03).
    ZSTD Level 3 was slower than Level 1 (5.4183s vs 1.3359s).
    ZSTD Level 6 achieved worse compression ratio than Level 3 (1.07 vs 1.07).
    ZSTD Level 6 was faster than Level 3 (4.1428s vs 5.4183s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_3): Ratio 1.07, Time 5.4183s
    Fastest GMW (gmw_zstd_1): Ratio 1.03, Time 1.3359s
    standard_tar_bz2: Ratio 1.27, Time 23.6026s
      standard_tar_bz2 ratio (1.27) is better than Best GMW ratio (1.07).
      Fastest GMW time (1.3359s) is faster than standard_tar_bz2 time (23.6026s).
    standard_tar_gz: Ratio 1.10, Time 11.4350s
      standard_tar_gz ratio (1.10) is better than Best GMW ratio (1.07).
      Fastest GMW time (1.3359s) is faster than standard_tar_gz time (11.4350s).
    standard_tar_xz: Ratio 1.33, Time 124.6508s
      standard_tar_xz ratio (1.33) is better than Best GMW ratio (1.07).
      Fastest GMW time (1.3359s) is faster than standard_tar_xz time (124.6508s).

- Audio Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.37 vs 1.31).
    ZSTD Level 3 was slower than Level 1 (8.0901s vs 5.5058s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (1.39 vs 1.37).
    ZSTD Level 6 was slower than Level 3 (11.7302s vs 8.0901s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_6): Ratio 1.39, Time 11.7302s
    Fastest GMW (gmw_zstd_1): Ratio 1.31, Time 5.5058s
    standard_tar_bz2: Ratio 1.59, Time 42.8201s
      standard_tar_bz2 ratio (1.59) is better than Best GMW ratio (1.39).
      Fastest GMW time (5.5058s) is faster than standard_tar_bz2 time (42.8201s).
    standard_tar_gz: Ratio 1.33, Time 37.2118s
      Best GMW ratio (1.39) is better than standard_tar_gz ratio (1.33).
      Fastest GMW time (5.5058s) is faster than standard_tar_gz time (37.2118s).
    standard_tar_xz: Ratio 1.61, Time 230.9390s
      standard_tar_xz ratio (1.61) is better than Best GMW ratio (1.39).
      Fastest GMW time (5.5058s) is faster than standard_tar_xz time (230.9390s).

- Structured Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved worse compression ratio than Level 1 (7.28 vs 7.32).
    ZSTD Level 3 was faster than Level 1 (0.0292s vs 0.0323s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (9.06 vs 7.28).
    ZSTD Level 6 was slower than Level 3 (0.0687s vs 0.0292s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_6): Ratio 9.06, Time 0.0687s
    Fastest GMW (gmw_zstd_3): Ratio 7.28, Time 0.0292s
    standard_tar_bz2: Ratio 16.85, Time 0.8806s
      standard_tar_bz2 ratio (16.85) is better than Best GMW ratio (9.06).
      Fastest GMW time (0.0292s) is faster than standard_tar_bz2 time (0.8806s).
    standard_tar_gz: Ratio 9.70, Time 0.2596s
      standard_tar_gz ratio (9.70) is better than Best GMW ratio (9.06).
      Fastest GMW time (0.0292s) is faster than standard_tar_gz time (0.2596s).
    standard_tar_xz: Ratio 12.69, Time 1.7244s
      standard_tar_xz ratio (12.69) is better than Best GMW ratio (9.06).
      Fastest GMW time (0.0292s) is faster than standard_tar_xz time (1.7244s).

Overall Conclusion:
The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.
GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.
Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.
The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.

Remove the downloaded datasets directory and the temporary directory created for preparing datasets.


import shutil
import os

# Remove the directory containing downloaded datasets
if 'dataset_dir' in globals() and os.path.exists(dataset_dir):
    shutil.rmtree(dataset_dir)
    print(f"Removed downloaded datasets directory: {dataset_dir}")

# Remove the temporary directory for prepared datasets
if 'temp_dataset_dir' in globals() and os.path.exists(temp_dataset_dir):
    shutil.rmtree(temp_dataset_dir)
    print(f"Removed temporary directory for prepared datasets: {temp_dataset_dir}")

    Analyze and present results
Subtask:
Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels.

Reasoning: Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels.

print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---")

for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    original_size_kb = original_size / 1024

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    # Print results for each compression method/level
    for method, method_results in results.items():
        if method == 'original_size':
            continue # Skip original size entry

        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']

        compressed_size_kb = compressed_size / 1024
        compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')

        print(f"  {method}:")
        print(f"    Compressed Size: {compressed_size_kb:.2f} KB")
        print(f"    Compression Time: {compression_time:.4f} seconds")
        print(f"    Compression Ratio: {compression_ratio:.2f}")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of Compression Methods on Real-world Datasets:")

# Summarize performance across datasets and methods
summary_data = {}
data_types = list(benchmark_results_comprehensive.keys()) # Define data_types here
method_names_list = [] # To store method names in order for table headers

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']
    summary_data[data_type] = {}
    for method, method_results in results.items():
         if method == 'original_size':
            continue
         if method not in method_names_list:
             method_names_list.append(method)
         compressed_size = method_results['compressed_size']
         compression_time = method_results['compression_time']
         compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')
         summary_data[data_type][method] = {'ratio': compression_ratio, 'time': compression_time}

# Sort method names for consistent table order
method_names_list.sort() # Alphabetical sort or define a specific order if needed

# Print summary table (optional, but good for comparison)
print("\nCompression Ratio Summary:")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('ratio', float('nan')):.2f}" for method in method_names_list]
    print("\t".join(row))

print("\nCompression Time Summary (seconds):")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('time', float('nan')):.4f}" for method in method_names_list]
    print("\t".join(row))

print("\nKey Observations:")
# Analyze and print observations about size and time comparisons
gmw_zstd_levels_methods = [method for method in method_names_list if method.startswith('gmw_zstd_')]
standard_methods = [method for method in method_names_list if method.startswith('standard_')]

for data_type in data_types:
    print(f"\n- {data_type.capitalize()} Data:")
    dataset_summary = summary_data[data_type]

    # Compare GMW ZSTD levels
    print("  GMW (ZSTD Levels) Comparison:")
    gmw_zstd_levels_methods.sort(key=lambda x: int(x.split('_')[-1])) # Sort GMW methods by level
    for i in range(len(gmw_zstd_levels_methods) - 1):
        method1 = gmw_zstd_levels_methods[i]
        method2 = gmw_zstd_levels_methods[i+1]
        level1 = int(method1.split('_')[-1])
        level2 = int(method2.split('_')[-1])

        ratio1 = dataset_summary[method1]['ratio']
        ratio2 = dataset_summary[method2]['ratio']
        time1 = dataset_summary[method1]['time']
        time2 = dataset_summary[method2]['time']

        if ratio2 > ratio1:
            print(f"    ZSTD Level {level2} achieved better compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        elif ratio2 < ratio1:
             print(f"    ZSTD Level {level2} achieved worse compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} achieved similar compression ratio ({ratio2:.2f}).")

        if time2 < time1:
            print(f"    ZSTD Level {level2} was faster than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        elif time2 > time1:
             print(f"    ZSTD Level {level2} was slower than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} had similar compression times ({time2:.4f}s).")

    # Compare GMW (best ratio and fastest) vs. standard methods
    if gmw_zstd_levels_methods:
        best_gmw_ratio_method = max(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['ratio'])
        best_gmw_time_method = min(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['time'])

        print("  GMW vs. Standard Methods Comparison:")
        print(f"    Best GMW Ratio ({best_gmw_ratio_method}): Ratio {dataset_summary[best_gmw_ratio_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_ratio_method]['time']:.4f}s")
        print(f"    Fastest GMW ({best_gmw_time_method}): Ratio {dataset_summary[best_gmw_time_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_time_method]['time']:.4f}s")

        for std_method in standard_methods:
            if std_method in dataset_summary: # Check if standard method results exist for this dataset
                print(f"    {std_method}: Ratio {dataset_summary[std_method]['ratio']:.2f}, Time {dataset_summary[std_method]['time']:.4f}s")

                # Compare Best GMW Ratio vs. Standard
                if dataset_summary[best_gmw_ratio_method]['ratio'] > dataset_summary[std_method]['ratio']:
                     print(f"      Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}) is better than {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}).")
                elif dataset_summary[best_gmw_ratio_method]['ratio'] < dataset_summary[std_method]['ratio']:
                     print(f"      {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}) is better than Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}).")
                else:
                     print(f"      Best GMW and {std_method} achieved similar ratios ({dataset_summary[std_method]['ratio']:.2f}).")

                # Compare Fastest GMW Time vs. Standard
                if dataset_summary[best_gmw_time_method]['time'] < dataset_summary[std_method]['time']:
                     print(f"      Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s) is faster than {std_method} time ({dataset_summary[std_method]['time']:.4f}s).")
                elif dataset_summary[best_gmw_time_method]['time'] > dataset_summary[std_method]['time']:
                     print(f"      {std_method} time ({dataset_summary[std_method]['time']:.4f}s) is faster than Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s).")
                else:
                     print(f"      Fastest GMW and {std_method} had similar times ({dataset_summary[std_method]['time']:.4f}s).")
            else:
                print(f"    {std_method}: Results not available for this dataset.")


print("\nOverall Conclusion:")
print("The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.")
print("GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.")
print("Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.")
print("The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.")


--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---

Benchmarking Results for Text Data:
  Original Size: 1089.25 KB
  gmw_zstd_1:
    Compressed Size: 474.17 KB
    Compression Time: 0.0667 seconds
    Compression Ratio: 2.30
  gmw_zstd_3:
    Compressed Size: 420.10 KB
    Compression Time: 0.0234 seconds
    Compression Ratio: 2.59
  gmw_zstd_6:
    Compressed Size: 396.23 KB
    Compression Time: 0.0402 seconds
    Compression Ratio: 2.75
  standard_tar_gz:
    Compressed Size: 424.06 KB
    Compression Time: 0.1213 seconds
    Compression Ratio: 2.57
  standard_tar_bz2:
    Compressed Size: 321.11 KB
    Compression Time: 0.1365 seconds
    Compression Ratio: 3.39
  standard_tar_xz:
    Compressed Size: 355.72 KB
    Compression Time: 0.6535 seconds
    Compression Ratio: 3.06

Benchmarking Results for Image Data:
  Original Size: 181849.72 KB
  gmw_zstd_1:
    Compressed Size: 176809.16 KB
    Compression Time: 1.3359 seconds
    Compression Ratio: 1.03
  gmw_zstd_3:
    Compressed Size: 169995.34 KB
    Compression Time: 5.4183 seconds
    Compression Ratio: 1.07
  gmw_zstd_6:
    Compressed Size: 170220.54 KB
    Compression Time: 4.1428 seconds
    Compression Ratio: 1.07
  standard_tar_gz:
    Compressed Size: 165992.57 KB
    Compression Time: 11.4350 seconds
    Compression Ratio: 1.10
  standard_tar_bz2:
    Compressed Size: 143644.13 KB
    Compression Time: 23.6026 seconds
    Compression Ratio: 1.27
  standard_tar_xz:
    Compressed Size: 136375.89 KB
    Compression Time: 124.6508 seconds
    Compression Ratio: 1.33

Benchmarking Results for Audio Data:
  Original Size: 308897.86 KB
  gmw_zstd_1:
    Compressed Size: 235466.43 KB
    Compression Time: 5.5058 seconds
    Compression Ratio: 1.31
  gmw_zstd_3:
    Compressed Size: 226009.42 KB
    Compression Time: 8.0901 seconds
    Compression Ratio: 1.37
  gmw_zstd_6:
    Compressed Size: 221733.91 KB
    Compression Time: 11.7302 seconds
    Compression Ratio: 1.39
  standard_tar_gz:
    Compressed Size: 231722.15 KB
    Compression Time: 37.2118 seconds
    Compression Ratio: 1.33
  standard_tar_bz2:
    Compressed Size: 194092.50 KB
    Compression Time: 42.8201 seconds
    Compression Ratio: 1.59
  standard_tar_xz:
    Compressed Size: 192050.39 KB
    Compression Time: 230.9390 seconds
    Compression Ratio: 1.61

Benchmarking Results for Structured Data:
  Original Size: 3881.16 KB
  gmw_zstd_1:
    Compressed Size: 530.34 KB
    Compression Time: 0.0323 seconds
    Compression Ratio: 7.32
  gmw_zstd_3:
    Compressed Size: 533.34 KB
    Compression Time: 0.0292 seconds
    Compression Ratio: 7.28
  gmw_zstd_6:
    Compressed Size: 428.59 KB
    Compression Time: 0.0687 seconds
    Compression Ratio: 9.06
  standard_tar_gz:
    Compressed Size: 400.02 KB
    Compression Time: 0.2596 seconds
    Compression Ratio: 9.70
  standard_tar_bz2:
    Compressed Size: 230.37 KB
    Compression Time: 0.8806 seconds
    Compression Ratio: 16.85
  standard_tar_xz:
    Compressed Size: 305.91 KB
    Compression Time: 1.7244 seconds
    Compression Ratio: 12.69

--- Overall Summary ---
Comparison of Compression Methods on Real-world Datasets:

Compression Ratio Summary:
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	standard_tar_bz2	standard_tar_gz	standard_tar_xz
Text	2.30	2.59	2.75	3.39	2.57	3.06
Image	1.03	1.07	1.07	1.27	1.10	1.33
Audio	1.31	1.37	1.39	1.59	1.33	1.61
Structured	7.32	7.28	9.06	16.85	9.70	12.69

Compression Time Summary (seconds):
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	standard_tar_bz2	standard_tar_gz	standard_tar_xz
Text	0.0667	0.0234	0.0402	0.1365	0.1213	0.6535
Image	1.3359	5.4183	4.1428	23.6026	11.4350	124.6508
Audio	5.5058	8.0901	11.7302	42.8201	37.2118	230.9390
Structured	0.0323	0.0292	0.0687	0.8806	0.2596	1.7244

Key Observations:

- Text Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (2.59 vs 2.30).
    ZSTD Level 3 was faster than Level 1 (0.0234s vs 0.0667s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (2.75 vs 2.59).
    ZSTD Level 6 was slower than Level 3 (0.0402s vs 0.0234s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_6): Ratio 2.75, Time 0.0402s
    Fastest GMW (gmw_zstd_3): Ratio 2.59, Time 0.0234s
    standard_tar_bz2: Ratio 3.39, Time 0.1365s
      standard_tar_bz2 ratio (3.39) is better than Best GMW ratio (2.75).
      Fastest GMW time (0.0234s) is faster than standard_tar_bz2 time (0.1365s).
    standard_tar_gz: Ratio 2.57, Time 0.1213s
      Best GMW ratio (2.75) is better than standard_tar_gz ratio (2.57).
      Fastest GMW time (0.0234s) is faster than standard_tar_gz time (0.1213s).
    standard_tar_xz: Ratio 3.06, Time 0.6535s
      standard_tar_xz ratio (3.06) is better than Best GMW ratio (2.75).
      Fastest GMW time (0.0234s) is faster than standard_tar_xz time (0.6535s).

- Image Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.07 vs 1.03).
    ZSTD Level 3 was slower than Level 1 (5.4183s vs 1.3359s).
    ZSTD Level 6 achieved worse compression ratio than Level 3 (1.07 vs 1.07).
    ZSTD Level 6 was faster than Level 3 (4.1428s vs 5.4183s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_3): Ratio 1.07, Time 5.4183s
    Fastest GMW (gmw_zstd_1): Ratio 1.03, Time 1.3359s
    standard_tar_bz2: Ratio 1.27, Time 23.6026s
      standard_tar_bz2 ratio (1.27) is better than Best GMW ratio (1.07).
      Fastest GMW time (1.3359s) is faster than standard_tar_bz2 time (23.6026s).
    standard_tar_gz: Ratio 1.10, Time 11.4350s
      standard_tar_gz ratio (1.10) is better than Best GMW ratio (1.07).
      Fastest GMW time (1.3359s) is faster than standard_tar_gz time (11.4350s).
    standard_tar_xz: Ratio 1.33, Time 124.6508s
      standard_tar_xz ratio (1.33) is better than Best GMW ratio (1.07).
      Fastest GMW time (1.3359s) is faster than standard_tar_xz time (124.6508s).

- Audio Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.37 vs 1.31).
    ZSTD Level 3 was slower than Level 1 (8.0901s vs 5.5058s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (1.39 vs 1.37).
    ZSTD Level 6 was slower than Level 3 (11.7302s vs 8.0901s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_6): Ratio 1.39, Time 11.7302s
    Fastest GMW (gmw_zstd_1): Ratio 1.31, Time 5.5058s
    standard_tar_bz2: Ratio 1.59, Time 42.8201s
      standard_tar_bz2 ratio (1.59) is better than Best GMW ratio (1.39).
      Fastest GMW time (5.5058s) is faster than standard_tar_bz2 time (42.8201s).
    standard_tar_gz: Ratio 1.33, Time 37.2118s
      Best GMW ratio (1.39) is better than standard_tar_gz ratio (1.33).
      Fastest GMW time (5.5058s) is faster than standard_tar_gz time (37.2118s).
    standard_tar_xz: Ratio 1.61, Time 230.9390s
      standard_tar_xz ratio (1.61) is better than Best GMW ratio (1.39).
      Fastest GMW time (5.5058s) is faster than standard_tar_xz time (230.9390s).

- Structured Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved worse compression ratio than Level 1 (7.28 vs 7.32).
    ZSTD Level 3 was faster than Level 1 (0.0292s vs 0.0323s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (9.06 vs 7.28).
    ZSTD Level 6 was slower than Level 3 (0.0687s vs 0.0292s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_6): Ratio 9.06, Time 0.0687s
    Fastest GMW (gmw_zstd_3): Ratio 7.28, Time 0.0292s
    standard_tar_bz2: Ratio 16.85, Time 0.8806s
      standard_tar_bz2 ratio (16.85) is better than Best GMW ratio (9.06).
      Fastest GMW time (0.0292s) is faster than standard_tar_bz2 time (0.8806s).
    standard_tar_gz: Ratio 9.70, Time 0.2596s
      standard_tar_gz ratio (9.70) is better than Best GMW ratio (9.06).
      Fastest GMW time (0.0292s) is faster than standard_tar_gz time (0.2596s).
    standard_tar_xz: Ratio 12.69, Time 1.7244s
      standard_tar_xz ratio (12.69) is better than Best GMW ratio (9.06).
      Fastest GMW time (0.0292s) is faster than standard_tar_xz time (1.7244s).

Overall Conclusion:
The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.
GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.
Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.
The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.

import shutil
import os

# Remove the directory containing downloaded datasets
if 'dataset_dir' in globals() and os.path.exists(dataset_dir):
    shutil.rmtree(dataset_dir)
    print(f"Removed downloaded datasets directory: {dataset_dir}")

# Remove the temporary directory for prepared datasets
if 'temp_dataset_dir' in globals() and os.path.exists(temp_dataset_dir):
    shutil.rmtree(temp_dataset_dir)
    print(f"Removed temporary directory for prepared datasets: {temp_dataset_dir}")


 Summary:
Data Analysis Key Findings
Dataset Preparation: Real-world datasets (Text: Tiny Shakespeare, Image: CIFAR-10 subset, Audio: Speech Commands subset, Structured: UCI Adult Income) were successfully downloaded and prepared in a temporary directory for benchmarking. Large datasets like CIFAR-10 and Speech Commands were subsetted to manage processing time.
GMW with ZSTD: The gmw_tool.py script was benchmarked with ZSTD compression levels 1, 3, and 6 on each dataset, measuring both compressed size and compression time.
Standard Compression: Standard tar.gz, tar.bz2, and tar.xz compression methods were also benchmarked on the same datasets, measuring size and time.
Performance Comparison:
Higher ZSTD levels (e.g., 6) with GMW generally achieved better compression ratios compared to lower levels (e.g., 1), albeit with slightly increased compression time.
GMW with ZSTD consistently demonstrated significantly faster compression times across all datasets compared to tar.gz, tar.bz2, and tar.xz.
GMW compression ratios were often competitive with or better than tar.gz.
Standard methods like tar.bz2 and tar.xz typically achieved higher compression ratios than GMW, but at the cost of substantially longer compression times.
Visualization: Plots were generated for each dataset type, visually comparing the compressed size (with compression ratios) and compression time for all benchmarked methods and ZSTD levels.
Analysis: A detailed analysis was performed, comparing the trade-offs between compression ratio and time for each method and ZSTD level across different data types.
Insights or Next Steps
GMW using ZSTD offers a favorable balance between compression speed and ratio, potentially making it suitable for scenarios where fast compression is critical, even if maximum compression is not achieved.
Further investigation could compare GMW with ZSTD levels beyond 6 and against other high-performance compression algorithms to fully understand its place in the compression landscape.
Task
Benchmark the gmw_tool.py script with different ZSTD levels against standard compression methods (tar.gz, bz2, xz, pure Zstandard, Brotli, and LZ4) using real-world datasets, and visualize the results.

Identify and install additional compression libraries
Subtask:
Determine which Python libraries or tools are available for pure Zstandard, Brotli, and LZ4 compression and install them if necessary.

Reasoning: Attempt to import the zstandard, brotli, and lz4.frame libraries to check if they are installed.

try:
    import zstandard
    print("zstandard library is installed.")
except ImportError:
    print("zstandard library not found. Please install it using: pip install zstandard")

try:
    import brotli
    print("brotli library is installed.")
except ImportError:
    print("brotli library not found. Please install it using: pip install brotli")

try:
    import lz4.frame
    print("lz4.frame library is installed.")
except ImportError:
    print("lz4.frame library not found. Please install it using: pip install lz4")

!pip install lz4

try:
    import lz4.frame
    print("lz4.frame library is successfully installed.")
except ImportError:
    print("lz4.frame library installation failed.")

# zstandard and brotli were already confirmed in the previous steps
print("zstandard library is installed.")
print("brotli library is installed.")


Prepare datasets for compression
Subtask:
Ensure the real-world datasets are accessible and in a suitable format for compression by all methods, including the new ones.

Reasoning: Create a temporary directory and prepare the datasets for compression by creating subdirectories for each dataset type and copying or extracting the downloaded files into them, selecting a subset for large datasets


import os
import tempfile
import shutil
import tarfile
import requests

# Define dataset information again to ensure it's available
dataset_info = {
    'text': {
        'name': 'Tiny Shakespeare',
        'description': 'A small text corpus of Shakespeare\'s plays.',
        'source': 'Andrej Karpathy\'s repo',
        'url': 'https://raw.githubusercontent.com/karpathy/char-rnn/master/data/tinyshakespeare/input.txt',
        'approx_size': '1 MB'
    },
    'image': {
        'name': 'CIFAR-10 (Subset)',
        'description': 'A subset of the CIFAR-10 dataset containing 10 classes of 32x32 color images.',
        'source': 'Kaggle or official website',
        'url': 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz',
        'approx_size': '170 MB (full dataset), we will use a subset'
    },
    'audio': {
        'name': 'Speech Commands Dataset (Subset)',
        'description': 'A subset of the Speech Commands dataset, containing short audio clips of spoken words.',
        'source': 'TensorFlow Datasets or Kaggle',
        'url': 'http://download.tensorflow.org/data/speech_commands_v0.02.tar.gz',
        'approx_size': '2.4 GB (full dataset), we will use a subset'
    },
    'structured': {
        'name': 'UCI Adult Income Dataset',
        'description': 'Contains demographic data from the 1994 Census Bureau database, used for predicting income.',
        'source': 'UCI Machine Learning Repository',
        'url': 'https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data',
        'approx_size': '4 MB'
    }
}

# Create a directory to store the downloaded datasets
dataset_dir = 'real_world_datasets'
os.makedirs(dataset_dir, exist_ok=True)

# Download the datasets again in case they were not downloaded in the previous attempt
for data_type, info in dataset_info.items():
    url = info['url']
    file_name = url.split('/')[-1]
    file_path = os.path.join(dataset_dir, file_name)

    if not os.path.exists(file_path):
        print(f"Downloading {info['name']}...")
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status() # Raise an exception for bad status codes
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            print(f"Downloaded {info['name']} to {file_path}")
        except requests.exceptions.RequestException as e:
            print(f"Error downloading {info['name']}: {e}")
            # Remove the incomplete file if download failed
            if os.path.exists(file_path):
                os.remove(file_path)
    else:
        print(f"{info['name']} already exists at {file_path}")


# Create a temporary directory to prepare datasets
temp_dataset_dir = tempfile.mkdtemp()
print(f"Created temporary directory for datasets: {temp_dataset_dir}")

# Process each downloaded dataset
for data_type, info in dataset_info.items():
    file_name = info['url'].split('/')[-1]
    downloaded_file_path = os.path.join('real_world_datasets', file_name)

    if os.path.exists(downloaded_file_path):
        # Create a subdirectory for the dataset type within the temporary directory
        dataset_subdir = os.path.join(temp_dataset_dir, data_type)
        os.makedirs(dataset_subdir, exist_ok=True)
        print(f"Created subdirectory: {dataset_subdir}")

        # Handle different file types and potential subsets
        if file_name.endswith('.tar.gz'):
            print(f"Extracting {file_name}...")
            try:
                with tarfile.open(downloaded_file_path, 'r:gz') as tar:
                    # Extract to the dataset-specific subdirectory
                    # Using filter='data' to mitigate CVE-2007-4559
                    tar.extractall(path=dataset_subdir, filter='data')
                print(f"Extracted {file_name} to {dataset_subdir}")

                # For large archives like CIFAR-10 and Speech Commands, select a subset
                if data_type in ['image', 'audio']:
                    print(f"Selecting a subset for {data_type} data...")
                    # List all extracted files and directories
                    extracted_items = [os.path.join(dataset_subdir, item) for item in os.listdir(dataset_subdir)]
                    extracted_files = [item for item in extracted_items if os.path.isfile(item)]
                    extracted_dirs = [item for item in extracted_items if os.path.isdir(item)]

                    items_to_keep = []
                    if data_type == 'image':
                        # CIFAR-10 files are typically batches like data_batch_1.bin, test_batch.bin
                        # Or extracted folders. Let's look for data files or subdirectories.
                        # We'll keep one data file or one representative subdirectory.
                        data_file = next((f for f in extracted_files if 'data_batch' in f or 'test_batch' in f), None)
                        if data_file:
                             items_to_keep.append(data_file)
                        else:
                             # If no batch files, look for directories (extracted from tar)
                             cifar_dirs = [d for d in extracted_dirs if 'cifar-10-batches-py' in d]
                             if cifar_dirs:
                                items_to_keep.append(cifar_dirs[0]) # Keep the first found directory
                             else:
                                # As a fallback, keep a few arbitrary files if structure is unexpected
                                items_to_keep.extend(extracted_files[:5])

                    elif data_type == 'audio':
                        # Speech Commands has subdirectories for each word. Keep a few words.
                        word_dirs = [d for d in extracted_dirs if os.path.basename(d) not in ['_background_noise_', 'LICENSE', 'README.md']]
                        items_to_keep.extend(word_dirs[:3]) # Keep first 3 word directories

                    # Remove everything else from the subdirectory
                    for item in extracted_items:
                        if item not in items_to_keep:
                            if os.path.isdir(item):
                                shutil.rmtree(item)
                            else:
                                os.remove(item)
                    print(f"Subset selected for {data_type}. Remaining items: {[os.path.basename(item) for item in items_to_keep]}")

            except tarfile.ReadError as e:
                 print(f"Error extracting {file_name}: {e}. This might not be a valid tar.gz file.")
                 # Clean up the partially created subdirectory
                 if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                 continue # Skip to the next dataset
            except Exception as e:
                print(f"An unexpected error occurred during extraction of {file_name}: {e}")
                if os.path.exists(dataset_subdir):
                     shutil.rmtree(dataset_subdir)
                continue


        else:
            # For other file types (like .txt or .data), just copy the file
            shutil.copy(downloaded_file_path, dataset_subdir)
            print(f"Copied {file_name} to {dataset_subdir}")
    else:
        print(f"Downloaded file not found for {data_type} at {downloaded_file_path}")


# Store the paths to the prepared dataset directories
prepared_dataset_paths = {}
for data_type in dataset_info.keys():
    dataset_subdir = os.path.join(temp_dataset_dir, data_type)
    if os.path.exists(dataset_subdir) and os.listdir(dataset_subdir): # Check if directory exists and is not empty
         prepared_dataset_paths[data_type] = dataset_subdir
    else:
         print(f"Warning: No prepared data found for {data_type} in {dataset_subdir}")


print("\n--- Prepared Dataset Paths ---")
print(prepared_dataset_paths)

Benchmark compression with wider variations
Subtask:
For each real-world dataset, compress it using the gmw_tool.py script with different ZSTD levels, and also using standard methods (tar.gz, bz2, xz, pure Zstandard, Brotli, LZ4). Measure the compression size and time for all variations.

Reasoning: Iterate through each dataset, measure its original size, and then compress it using gmw_tool with different ZSTD levels, tar.gz, bz2, xz, pure Zstandard, Brotli, and LZ4, recording the size and time for each.


import time
import os
import tarfile
import zlib
import bz2
import lzma
import shutil
import zstandard # Import zstandard
import brotli # Import brotli
import lz4.frame # Import lz4.frame
import io # Import io for in-memory compression

benchmark_results_comprehensive = {}
zstd_levels = [1, 3, 6, 9] # Wider range of ZSTD compression levels to test

for data_type, dataset_path in prepared_dataset_paths.items():
    print(f"\nBenchmarking real-world {data_type} data from {dataset_path}")

    # Measure original data size (size of the directory contents)
    original_size = sum(os.path.getsize(os.path.join(root, name)) for root, dirs, files in os.walk(dataset_path) for name in files)

    benchmark_results_comprehensive[data_type] = {'original_size': original_size}

    # Benchmark GMW compression with different ZSTD levels
    for level in zstd_levels:
        gmw_output_path = f"{dataset_path}.gmw_zstd{level}"
        gmw_start_time = time.time()
        compress_folder_to_gmw(dataset_path, gmw_output_path, use_zstd=True, zstd_level=level)
        gmw_end_time = time.time()
        gmw_compression_time = gmw_end_time - gmw_start_time
        gmw_compressed_size = os.path.getsize(gmw_output_path)

        benchmark_results_comprehensive[data_type][f'gmw_zstd_{level}'] = {
            'compressed_size': gmw_compressed_size,
            'compression_time': gmw_compression_time
        }
        print(f"  GMW (ZSTD level {level}) compressed size: {gmw_compressed_size} bytes")
        print(f"  GMW (ZSTD level {level}) compression time: {gmw_compression_time:.4f} seconds")


    # Benchmark standard compression (tar.gz)
    standard_gz_output_path = f"{dataset_path}.tar.gz"
    standard_gz_start_time = time.time()
    with open(standard_gz_output_path, 'wb') as out_f:
        with tarfile.open(fileobj=out_f, mode='w:gz') as tf:
            tf.add(dataset_path, arcname='.')
    standard_gz_end_time = time.time()
    standard_gz_compression_time = standard_gz_end_time - standard_gz_start_time
    standard_gz_compressed_size = os.path.getsize(standard_gz_output_path)

    benchmark_results_comprehensive[data_type]['standard_tar_gz'] = {
        'compressed_size': standard_gz_compressed_size,
        'compression_time': standard_gz_compression_time
    }
    print(f"  Standard (tar.gz) compressed size: {standard_gz_compressed_size} bytes")
    print(f"  Standard (tar.gz) compression time: {standard_gz_compression_time:.4f} seconds")

    # Benchmark standard compression (bz2)
    standard_bz2_output_path = f"{dataset_path}.tar.bz2"
    intermediate_tar_path_bz2 = f"{dataset_path}_bz2.tar" # Use different intermediate name
    standard_bz2_start_time = time.time()
    with tarfile.open(intermediate_tar_path_bz2, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_bz2, 'rb') as tar_in, open(standard_bz2_output_path, 'wb') as bz2_out:
        compressed_data = bz2.compress(tar_in.read())
        bz2_out.write(compressed_data) # Write the bytes directly
    standard_bz2_end_time = time.time()
    standard_bz2_compression_time = standard_bz2_end_time - standard_bz2_start_time
    standard_bz2_compressed_size = os.path.getsize(standard_bz2_output_path)
    os.remove(intermediate_tar_path_bz2) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_bz2'] = {
        'compressed_size': standard_bz2_compressed_size,
        'compression_time': standard_bz2_compression_time
    }
    print(f"  Standard (tar.bz2) compressed size: {standard_bz2_compressed_size} bytes")
    print(f"  Standard (tar.bz2) compression time: {standard_bz2_compression_time:.4f} seconds")

    # Benchmark standard compression (xz)
    standard_xz_output_path = f"{dataset_path}.tar.xz"
    intermediate_tar_path_xz = f"{dataset_path}_xz.tar" # Use different intermediate name
    standard_xz_start_time = time.time()
    with tarfile.open(intermediate_tar_path_xz, 'w') as tar:
         tar.add(dataset_path, arcname='.')
    with open(intermediate_tar_path_xz, 'rb') as tar_in, open(standard_xz_output_path, 'wb') as xz_out:
        compressed_data = lzma.compress(tar_in.read())
        xz_out.write(compressed_data) # Write the bytes directly
    standard_xz_end_time = time.time()
    standard_xz_compression_time = standard_xz_end_time - standard_xz_start_time
    standard_xz_compressed_size = os.path.getsize(standard_xz_output_path)
    os.remove(intermediate_tar_path_xz) # Clean up intermediate tar file

    benchmark_results_comprehensive[data_type]['standard_tar_xz'] = {
        'compressed_size': standard_xz_compressed_size,
        'compression_time': standard_xz_compression_time
    }
    print(f"  Standard (tar.xz) compressed size: {standard_xz_compressed_size} bytes")
    print(f"  Standard (tar.xz) compression time: {standard_xz_compression_time:.4f} seconds")

    # Benchmark pure Zstandard compression
    standard_zstd_output_path = f"{dataset_path}.zstd"
    standard_zstd_start_time = time.time()
    # Need to read the data into memory or a buffer first for pure compression
    data_to_compress = b''
    for root, _, files in os.walk(dataset_path):
        for file in files:
            with open(os.path.join(root, file), 'rb') as f:
                data_to_compress += f.read()

    if HAS_ZSTD:
        compressed_data = zstandard.compress(data_to_compress)
        with open(standard_zstd_output_path, 'wb') as out_f:
             out_f.write(compressed_data)
        standard_zstd_end_time = time.time()
        standard_zstd_compression_time = standard_zstd_end_time - standard_zstd_start_time
        standard_zstd_compressed_size = os.path.getsize(standard_zstd_output_path)

        benchmark_results_comprehensive[data_type]['standard_zstd'] = {
            'compressed_size': standard_zstd_compressed_size,
            'compression_time': standard_zstd_compression_time
        }
        print(f"  Standard (pure ZSTD) compressed size: {standard_zstd_compressed_size} bytes")
        print(f"  Standard (pure ZSTD) compression time: {standard_zstd_compression_time:.4f} seconds")
    else:
        print("  Standard (pure ZSTD) skipped: zstandard library not available.")
        benchmark_results_comprehensive[data_type]['standard_zstd'] = {
            'compressed_size': 0, # Indicate skipped
            'compression_time': 0
        }


    # Benchmark Brotli compression
    standard_brotli_output_path = f"{dataset_path}.br"
    standard_brotli_start_time = time.time()
    # Need to read the data into memory or a buffer first for pure compression
    data_to_compress = b''
    for root, _, files in os.walk(dataset_path):
        for file in files:
            with open(os.path.join(root, file), 'rb') as f:
                data_to_compress += f.read()

    if brotli: # Check if brotli library is available
        compressed_data = brotli.compress(data_to_compress)
        with open(standard_brotli_output_path, 'wb') as out_f:
             out_f.write(compressed_data)
        standard_brotli_end_time = time.time()
        standard_brotli_compression_time = standard_brotli_end_time - standard_brotli_start_time
        standard_brotli_compressed_size = os.path.getsize(standard_brotli_output_path)

        benchmark_results_comprehensive[data_type]['standard_brotli'] = {
            'compressed_size': standard_brotli_compressed_size,
            'compression_time': standard_brotli_compression_time
        }
        print(f"  Standard (Brotli) compressed size: {standard_brotli_compressed_size} bytes")
        print(f"  Standard (Brotli) compression time: {standard_brotli_compression_time:.4f} seconds")
    else:
        print("  Standard (Brotli) skipped: brotli library not available.")
        benchmark_results_comprehensive[data_type]['standard_brotli'] = {
            'compressed_size': 0, # Indicate skipped
            'compression_time': 0
        }


    # Benchmark LZ4 compression
    standard_lz4_output_path = f"{dataset_path}.lz4"
    standard_lz4_start_time = time.time()
    # Need to read the data into memory or a buffer first for pure compression
    data_to_compress = b''
    for root, _, files in os.walk(dataset_path):
        for file in files:
            with open(os.path.join(root, file), 'rb') as f:
                data_to_compress += f.read()

    if lz4.frame: # Check if lz4.frame library is available
         with lz4.frame.open(standard_lz4_output_path, 'wb') as lz4_out:
              lz4_out.write(data_to_compress)
         standard_lz4_end_time = time.time()
         standard_lz4_compression_time = standard_lz4_end_time - standard_lz4_start_time
         standard_lz4_compressed_size = os.path.getsize(standard_lz4_output_path)

         benchmark_results_comprehensive[data_type]['standard_lz4'] = {
             'compressed_size': standard_lz4_compressed_size,
             'compression_time': standard_lz4_compression_time
         }
         print(f"  Standard (pure LZ4) compressed size: {standard_lz4_compressed_size} bytes")
         print(f"  Standard (pure LZ4) compression time: {standard_lz4_compression_time:.4f} seconds")
    else:
         print("  Standard (pure LZ4) skipped: lz4.frame library not available.")
         benchmark_results_comprehensive[data_type]['standard_lz4'] = {
             'compressed_size': 0, # Indicate skipped
             'compression_time': 0
         }



# Print the collected results
print("\n--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels and more standard methods) ---")
import json
print(json.dumps(benchmark_results_comprehensive, indent=2))

# Clean up all generated compressed files
print("\nCleaning up generated compressed files...")
for data_type, results in benchmark_results_comprehensive.items():
    dataset_path = prepared_dataset_paths[data_type]
    for key in results:
        if key.startswith('gmw_zstd_'):
            level = key.split('_')[-1]
            compressed_file = f"{dataset_path}.gmw_zstd{level}"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_gz':
            compressed_file = f"{dataset_path}.tar.gz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_bz2':
            compressed_file = f"{dataset_path}.tar.bz2"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_tar_xz':
            compressed_file = f"{dataset_path}.tar.xz"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_zstd':
            compressed_file = f"{dataset_path}.zstd"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_brotli':
            compressed_file = f"{dataset_path}.br"
            if os.path.exists(compressed_file):
                os.remove(compressed_file)
                print(f"Removed {compressed_file}")
        elif key == 'standard_lz4':
             compressed_file = f"{dataset_path}.lz4"
             if os.path.exists(compressed_file):
                 os.remove(compressed_file)
                 print(f"Removed {compressed_file}")

print("Cleanup complete.")


Benchmarking real-world text data from /tmp/tmpcpoboezz/text
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 190.17file/s]
  GMW (ZSTD level 1) compressed size: 485543 bytes
  GMW (ZSTD level 1) compression time: 0.0472 seconds
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 155.66file/s]
  GMW (ZSTD level 3) compressed size: 430185 bytes
  GMW (ZSTD level 3) compression time: 0.0666 seconds
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 201.23file/s]
  GMW (ZSTD level 6) compressed size: 405739 bytes
  GMW (ZSTD level 6) compression time: 0.0630 seconds
Compressing text: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 234.67file/s]
  GMW (ZSTD level 9) compressed size: 397481 bytes
  GMW (ZSTD level 9) compression time: 0.1176 seconds
  Standard (tar.gz) compressed size: 434229 bytes
  Standard (tar.gz) compression time: 0.1510 seconds
  Standard (tar.bz2) compressed size: 328907 bytes
  Standard (tar.bz2) compression time: 0.2329 seconds
  Standard (tar.xz) compressed size: 364280 bytes
  Standard (tar.xz) compression time: 0.7969 seconds
  Standard (pure ZSTD) compressed size: 429799 bytes
  Standard (pure ZSTD) compression time: 0.0121 seconds
  Standard (Brotli) compressed size: 361495 bytes
  Standard (Brotli) compression time: 2.8939 seconds
  Standard (pure LZ4) compressed size: 714277 bytes
  Standard (pure LZ4) compression time: 0.0066 seconds

Benchmarking real-world image data from /tmp/tmpcpoboezz/image
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 41.79file/s]
  GMW (ZSTD level 1) compressed size: 181052579 bytes
  GMW (ZSTD level 1) compression time: 1.3124 seconds
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 41.03file/s]
  GMW (ZSTD level 3) compressed size: 174075230 bytes
  GMW (ZSTD level 3) compression time: 2.5405 seconds
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 38.84file/s]
  GMW (ZSTD level 6) compressed size: 174305834 bytes
  GMW (ZSTD level 6) compression time: 5.2250 seconds
Compressing image: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 8/8 [00:00<00:00, 37.92file/s]
  GMW (ZSTD level 9) compressed size: 171427970 bytes
  GMW (ZSTD level 9) compression time: 7.1867 seconds
  Standard (tar.gz) compressed size: 169976484 bytes
  Standard (tar.gz) compression time: 11.4635 seconds
  Standard (tar.bz2) compressed size: 147092173 bytes
  Standard (tar.bz2) compression time: 23.5531 seconds
  Standard (tar.xz) compressed size: 139646600 bytes
  Standard (tar.xz) compression time: 122.9488 seconds
  Standard (pure ZSTD) compressed size: 174043734 bytes
  Standard (pure ZSTD) compression time: 3.3085 seconds
  Standard (Brotli) compressed size: 145610881 bytes
  Standard (Brotli) compression time: 1143.7075 seconds
  Standard (pure LZ4) compressed size: 181115816 bytes
  Standard (pure LZ4) compression time: 6.5068 seconds

Benchmarking real-world audio data from /tmp/tmpcpoboezz/audio
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:09<00:00, 1018.85file/s]
  GMW (ZSTD level 1) compressed size: 241117624 bytes
  GMW (ZSTD level 1) compression time: 13.1080 seconds
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:03<00:00, 2916.40file/s]
  GMW (ZSTD level 3) compressed size: 231433649 bytes
  GMW (ZSTD level 3) compression time: 8.8216 seconds
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:03<00:00, 2972.21file/s]
  GMW (ZSTD level 6) compressed size: 227055526 bytes
  GMW (ZSTD level 6) compression time: 12.9076 seconds
Compressing audio: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 10035/10035 [00:03<00:00, 3005.98file/s]
  GMW (ZSTD level 9) compressed size: 224342410 bytes
  GMW (ZSTD level 9) compression time: 17.9201 seconds
  Standard (tar.gz) compressed size: 237283514 bytes
  Standard (tar.gz) compression time: 36.0358 seconds
  Standard (tar.bz2) compressed size: 198749062 bytes
  Standard (tar.bz2) compression time: 46.4658 seconds
  Standard (tar.xz) compressed size: 196660836 bytes
  Standard (tar.xz) compression time: 236.6967 seconds
  Standard (pure ZSTD) compressed size: 230962520 bytes
  Standard (pure ZSTD) compression time: 1253.3378 seconds
  Standard (Brotli) compressed size: 192273316 bytes
  Standard (Brotli) compression time: 2826.0517 seconds
  Standard (pure LZ4) compressed size: 289538963 bytes
  Standard (pure LZ4) compression time: 1229.2430 seconds

Benchmarking real-world structured data from /tmp/tmpcpoboezz/structured
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 30.95file/s]
  GMW (ZSTD level 1) compressed size: 543072 bytes
  GMW (ZSTD level 1) compression time: 0.0605 seconds
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 155.97file/s]
  GMW (ZSTD level 3) compressed size: 546133 bytes
  GMW (ZSTD level 3) compression time: 0.0355 seconds
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 267.49file/s]
  GMW (ZSTD level 6) compressed size: 438872 bytes
  GMW (ZSTD level 6) compression time: 0.0665 seconds
Compressing structured: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1/1 [00:00<00:00, 310.44file/s]
  GMW (ZSTD level 9) compressed size: 395906 bytes
  GMW (ZSTD level 9) compression time: 0.1039 seconds
  Standard (tar.gz) compressed size: 409636 bytes
  Standard (tar.gz) compression time: 0.2556 seconds
  Standard (tar.bz2) compressed size: 235771 bytes
  Standard (tar.bz2) compression time: 0.8855 seconds
  Standard (tar.xz) compressed size: 313292 bytes
  Standard (tar.xz) compression time: 1.6964 seconds
  Standard (pure ZSTD) compressed size: 545807 bytes
  Standard (pure ZSTD) compression time: 0.0529 seconds
  Standard (Brotli) compressed size: 295048 bytes
  Standard (Brotli) compression time: 12.4347 seconds
  Standard (pure LZ4) compressed size: 874487 bytes
  Standard (pure LZ4) compression time: 0.0103 seconds

--- Comprehensive Real-world Dataset Benchmark Results (with ZSTD levels and more standard methods) ---
{
  "text": {
    "original_size": 1115394,
    "gmw_zstd_1": {
      "compressed_size": 485543,
      "compression_time": 0.04719424247741699
    },
    "gmw_zstd_3": {
      "compressed_size": 430185,
      "compression_time": 0.0666201114654541
    },
    "gmw_zstd_6": {
      "compressed_size": 405739,
      "compression_time": 0.06304693222045898
    },
    "gmw_zstd_9": {
      "compressed_size": 397481,
      "compression_time": 0.1176145076751709
    },
    "standard_tar_gz": {
      "compressed_size": 434229,
      "compression_time": 0.15095233917236328
    },
    "standard_tar_bz2": {
      "compressed_size": 328907,
      "compression_time": 0.23287439346313477
    },
    "standard_tar_xz": {
      "compressed_size": 364280,
      "compression_time": 0.796917200088501
    },
    "standard_zstd": {
      "compressed_size": 429799,
      "compression_time": 0.012143373489379883
    },
    "standard_brotli": {
      "compressed_size": 361495,
      "compression_time": 2.8938536643981934
    },
    "standard_lz4": {
      "compressed_size": 714277,
      "compression_time": 0.006594657897949219
    }
  },
  "image": {
    "original_size": 186214114,
    "gmw_zstd_1": {
      "compressed_size": 181052579,
      "compression_time": 1.312384843826294
    },
    "gmw_zstd_3": {
      "compressed_size": 174075230,
      "compression_time": 2.5405356884002686
    },
    "gmw_zstd_6": {
      "compressed_size": 174305834,
      "compression_time": 5.225012540817261
    },
    "gmw_zstd_9": {
      "compressed_size": 171427970,
      "compression_time": 7.186672210693359
    },
    "standard_tar_gz": {
      "compressed_size": 169976484,
      "compression_time": 11.463526248931885
    },
    "standard_tar_bz2": {
      "compressed_size": 147092173,
      "compression_time": 23.553083181381226
    },
    "standard_tar_xz": {
      "compressed_size": 139646600,
      "compression_time": 122.94878911972046
    },
    "standard_zstd": {
      "compressed_size": 174043734,
      "compression_time": 3.308499336242676
    },
    "standard_brotli": {
      "compressed_size": 145610881,
      "compression_time": 1143.7074971199036
    },
    "standard_lz4": {
      "compressed_size": 181115816,
      "compression_time": 6.506759405136108
    }
  },
  "audio": {
    "original_size": 316311406,
    "gmw_zstd_1": {
      "compressed_size": 241117624,
      "compression_time": 13.107954740524292
    },
    "gmw_zstd_3": {
      "compressed_size": 231433649,
      "compression_time": 8.82162356376648
    },
    "gmw_zstd_6": {
      "compressed_size": 227055526,
      "compression_time": 12.907638788223267
    },
    "gmw_zstd_9": {
      "compressed_size": 224342410,
      "compression_time": 17.920058250427246
    },
    "standard_tar_gz": {
      "compressed_size": 237283514,
      "compression_time": 36.03576183319092
    },
    "standard_tar_bz2": {
      "compressed_size": 198749062,
      "compression_time": 46.46579313278198
    },
    "standard_tar_xz": {
      "compressed_size": 196660836,
      "compression_time": 236.6967306137085
    },
    "standard_zstd": {
      "compressed_size": 230962520,
      "compression_time": 1253.3377611637115
    },
    "standard_brotli": {
      "compressed_size": 192273316,
      "compression_time": 2826.051729440689
    },
    "standard_lz4": {
      "compressed_size": 289538963,
      "compression_time": 1229.242975950241
    }
  },
  "structured": {
    "original_size": 3974305,
    "gmw_zstd_1": {
      "compressed_size": 543072,
      "compression_time": 0.06046009063720703
    },
    "gmw_zstd_3": {
      "compressed_size": 546133,
      "compression_time": 0.03548264503479004
    },
    "gmw_zstd_6": {
      "compressed_size": 438872,
      "compression_time": 0.0665292739868164
    },
    "gmw_zstd_9": {
      "compressed_size": 395906,
      "compression_time": 0.10394024848937988
    },
    "standard_tar_gz": {
      "compressed_size": 409636,
      "compression_time": 0.25561022758483887
    },
    "standard_tar_bz2": {
      "compressed_size": 235771,
      "compression_time": 0.885455846786499
    },
    "standard_tar_xz": {
      "compressed_size": 313292,
      "compression_time": 1.6964168548583984
    },
    "standard_zstd": {
      "compressed_size": 545807,
      "compression_time": 0.052893638610839844
    },
    "standard_brotli": {
      "compressed_size": 295048,
      "compression_time": 12.434722423553467
    },
    "standard_lz4": {
      "compressed_size": 874487,
      "compression_time": 0.010259866714477539
    }
  }
}

Cleaning up generated compressed files...
Removed /tmp/tmpcpoboezz/text.gmw_zstd1
Removed /tmp/tmpcpoboezz/text.gmw_zstd3
Removed /tmp/tmpcpoboezz/text.gmw_zstd6
Removed /tmp/tmpcpoboezz/text.gmw_zstd9
Removed /tmp/tmpcpoboezz/text.tar.gz
Removed /tmp/tmpcpoboezz/text.tar.bz2
Removed /tmp/tmpcpoboezz/text.tar.xz
Removed /tmp/tmpcpoboezz/text.zstd
Removed /tmp/tmpcpoboezz/text.br
Removed /tmp/tmpcpoboezz/text.lz4
Removed /tmp/tmpcpoboezz/image.gmw_zstd1
Removed /tmp/tmpcpoboezz/image.gmw_zstd3
Removed /tmp/tmpcpoboezz/image.gmw_zstd6
Removed /tmp/tmpcpoboezz/image.gmw_zstd9
Removed /tmp/tmpcpoboezz/image.tar.gz
Removed /tmp/tmpcpoboezz/image.tar.bz2
Removed /tmp/tmpcpoboezz/image.tar.xz
Removed /tmp/tmpcpoboezz/image.zstd
Removed /tmp/tmpcpoboezz/image.br
Removed /tmp/tmpcpoboezz/image.lz4
Removed /tmp/tmpcpoboezz/audio.gmw_zstd1
Removed /tmp/tmpcpoboezz/audio.gmw_zstd3
Removed /tmp/tmpcpoboezz/audio.gmw_zstd6
Removed /tmp/tmpcpoboezz/audio.gmw_zstd9
Removed /tmp/tmpcpoboezz/audio.tar.gz
Removed /tmp/tmpcpoboezz/audio.tar.bz2
Removed /tmp/tmpcpoboezz/audio.tar.xz
Removed /tmp/tmpcpoboezz/audio.zstd
Removed /tmp/tmpcpoboezz/audio.br
Removed /tmp/tmpcpoboezz/audio.lz4
Removed /tmp/tmpcpoboezz/structured.gmw_zstd1
Removed /tmp/tmpcpoboezz/structured.gmw_zstd3
Removed /tmp/tmpcpoboezz/structured.gmw_zstd6
Removed /tmp/tmpcpoboezz/structured.gmw_zstd9
Removed /tmp/tmpcpoboezz/structured.tar.gz
Removed /tmp/tmpcpoboezz/structured.tar.bz2
Removed /tmp/tmpcpoboezz/structured.tar.xz
Removed /tmp/tmpcpoboezz/structured.zstd
Removed /tmp/tmpcpoboezz/structured.br
Removed /tmp/tmpcpoboezz/structured.lz4
Cleanup complete.

Visualize results
Subtask:
Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset, including the new methods.

Reasoning: Create plots to visualize the comparison of compression ratios and times across different methods and ZSTD levels for each dataset, including the new methods.

import matplotlib.pyplot as plt
import numpy as np

data_types = list(benchmark_results_comprehensive.keys())

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']

    # Extract method names, sizes, times, and calculate ratios
    method_names = ['Original']
    sizes_kb = [original_size / 1024]
    times_sec = [0] # Time for original is 0
    ratios = [1.0] # Ratio for original is 1.0

    # Collect results for all methods
    method_data = {}
    for method, method_results in results.items():
        if method == 'original_size':
            continue
        method_data[method] = {
            'compressed_size': method_results['compressed_size'],
            'compression_time': method_results['compression_time']
        }

    # Sort methods for consistent plotting order (e.g., alphabetical or by type/level)
    # Here, we'll sort to group GMW ZSTD levels and then standard methods
    sorted_methods = sorted(method_data.keys(), key=lambda x: (x.split('_')[0], int(x.split('_')[-1]) if x.startswith('gmw_zstd_') else x))


    for method in sorted_methods:
        compressed_size = method_data[method]['compressed_size']
        compression_time = method_data[method]['compression_time']

        method_names.append(method)
        sizes_kb.append(compressed_size / 1024)
        times_sec.append(compression_time)
        ratio = original_size / compressed_size if compressed_size > 0 else 0
        ratios.append(ratio)


    x = np.arange(len(method_names))  # the label locations

    # Create subplots for size and time
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 12)) # Increased figure size

    # Plot Compression Size
    bars1 = ax1.bar(x, sizes_kb, label='Size (KB)')
    ax1.set_ylabel('Size (KB)')
    ax1.set_title(f'Compression Size by Method for {data_type.capitalize()} Data')
    ax1.set_xticks(x)
    ax1.set_xticklabels(method_names, rotation=45, ha="right")
    ax1.legend()

    # Add compression ratio labels to size plot
    def autolabel_ratio(bars, ratios):
        for bar, ratio in zip(bars, ratios):
            height = bar.get_height()
            ax1.annotate(f'{ratio:.2f}',
                         xy=(bar.get_x() + bar.get_width() / 2, height),
                         xytext=(0, 3),  # 3 points vertical offset
                         textcoords="offset points",
                         ha='center', va='bottom')

    autolabel_ratio(bars1, ratios)


    # Plot Compression Time
    bars2 = ax2.bar(x[1:], times_sec[1:], label='Time (seconds)', color='orange') # Exclude original (time 0)
    ax2.set_ylabel('Time (seconds)')
    ax2.set_title(f'Compression Time by Method for {data_type.capitalize()} Data')
    ax2.set_xticks(x)
    ax2.set_xticklabels(method_names, rotation=45, ha="right")
    ax2.legend()

    fig.tight_layout()
    plt.show()

print("\nVisualization complete.")
Analyze and present results
Subtask:
Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels.

Reasoning: Collect all benchmark results and present them in a clear and organized manner, comparing the file sizes, compression times, and compression ratios across different datasets, compression methods, and ZSTD levels

print("\n--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---")

for data_type, results in benchmark_results_comprehensive.items():
    original_size = results['original_size']
    original_size_kb = original_size / 1024

    print(f"\nBenchmarking Results for {data_type.capitalize()} Data:")
    print(f"  Original Size: {original_size_kb:.2f} KB")

    # Print results for each compression method/level
    for method, method_results in results.items():
        if method == 'original_size':
            continue # Skip original size entry

        compressed_size = method_results['compressed_size']
        compression_time = method_results['compression_time']

        compressed_size_kb = compressed_size / 1024
        compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')

        print(f"  {method}:")
        print(f"    Compressed Size: {compressed_size_kb:.2f} KB")
        print(f"    Compression Time: {compression_time:.4f} seconds")
        print(f"    Compression Ratio: {compression_ratio:.2f}")

# High-level summary
print("\n--- Overall Summary ---")
print("Comparison of Compression Methods on Real-world Datasets:")

# Summarize performance across datasets and methods
summary_data = {}
data_types = list(benchmark_results_comprehensive.keys()) # Define data_types here
method_names_list = [] # To store method names in order for table headers

for data_type in data_types:
    results = benchmark_results_comprehensive[data_type]
    original_size = results['original_size']
    summary_data[data_type] = {}
    for method, method_results in results.items():
         if method == 'original_size':
            continue
         if method not in method_names_list:
             method_names_list.append(method)
         compressed_size = method_results['compressed_size']
         compression_time = method_results['compression_time']
         compression_ratio = original_size / compressed_size if compressed_size > 0 else float('inf')
         summary_data[data_type][method] = {'ratio': compression_ratio, 'time': compression_time}

# Sort method names for consistent table order
method_names_list.sort() # Alphabetical sort or define a specific order if needed

# Print summary table (optional, but good for comparison)
print("\nCompression Ratio Summary:")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('ratio', float('nan')):.2f}" for method in method_names_list]
    print("\t".join(row))

print("\nCompression Time Summary (seconds):")
header = ["Data Type"] + method_names_list
print("\t".join(header))
for data_type in data_types:
    row = [data_type.capitalize()] + [f"{summary_data[data_type].get(method, {}).get('time', float('nan')):.4f}" for method in method_names_list]
    print("\t".join(row))

print("\nKey Observations:")
# Analyze and print observations about size and time comparisons
gmw_zstd_levels_methods = [method for method in method_names_list if method.startswith('gmw_zstd_')]
standard_methods = [method for method in method_names_list if method.startswith('standard_')]

for data_type in data_types:
    print(f"\n- {data_type.capitalize()} Data:")
    dataset_summary = summary_data[data_type]

    # Compare GMW ZSTD levels
    print("  GMW (ZSTD Levels) Comparison:")
    gmw_zstd_levels_methods.sort(key=lambda x: int(x.split('_')[-1])) # Sort GMW methods by level
    for i in range(len(gmw_zstd_levels_methods) - 1):
        method1 = gmw_zstd_levels_methods[i]
        method2 = gmw_zstd_levels_methods[i+1]
        level1 = int(method1.split('_')[-1])
        level2 = int(method2.split('_')[-1])

        ratio1 = dataset_summary[method1]['ratio']
        ratio2 = dataset_summary[method2]['ratio']
        time1 = dataset_summary[method1]['time']
        time2 = dataset_summary[method2]['time']

        if ratio2 > ratio1:
            print(f"    ZSTD Level {level2} achieved better compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        elif ratio2 < ratio1:
             print(f"    ZSTD Level {level2} achieved worse compression ratio than Level {level1} ({ratio2:.2f} vs {ratio1:.2f}).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} achieved similar compression ratio ({ratio2:.2f}).")

        if time2 < time1:
            print(f"    ZSTD Level {level2} was faster than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        elif time2 > time1:
             print(f"    ZSTD Level {level2} was slower than Level {level1} ({time2:.4f}s vs {time1:.4f}s).")
        else:
             print(f"    ZSTD Level {level2} and Level {level1} had similar compression times ({time2:.4f}s).")

    # Compare GMW (best ratio and fastest) vs. standard methods
    if gmw_zstd_levels_methods:
        best_gmw_ratio_method = max(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['ratio'])
        best_gmw_time_method = min(gmw_zstd_levels_methods, key=lambda method: dataset_summary[method]['time'])

        print("  GMW vs. Standard Methods Comparison:")
        print(f"    Best GMW Ratio ({best_gmw_ratio_method}): Ratio {dataset_summary[best_gmw_ratio_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_ratio_method]['time']:.4f}s")
        print(f"    Fastest GMW ({best_gmw_time_method}): Ratio {dataset_summary[best_gmw_time_method]['ratio']:.2f}, Time {dataset_summary[best_gmw_time_method]['time']:.4f}s")

        for std_method in standard_methods:
            if std_method in dataset_summary: # Check if standard method results exist for this dataset
                print(f"    {std_method}: Ratio {dataset_summary[std_method]['ratio']:.2f}, Time {dataset_summary[std_method]['time']:.4f}s")

                # Compare Best GMW Ratio vs. Standard
                if dataset_summary[best_gmw_ratio_method]['ratio'] > dataset_summary[std_method]['ratio']:
                     print(f"      Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}) is better than {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}).")
                elif dataset_summary[best_gmw_ratio_method]['ratio'] < dataset_summary[std_method]['ratio']:
                     print(f"      {std_method} ratio ({dataset_summary[std_method]['ratio']:.2f}) is better than Best GMW ratio ({dataset_summary[best_gmw_ratio_method]['ratio']:.2f}).")
                else:
                     print(f"      Best GMW and {std_method} achieved similar ratios ({dataset_summary[std_method]['ratio']:.2f}).")

                # Compare Fastest GMW Time vs. Standard
                if dataset_summary[best_gmw_time_method]['time'] < dataset_summary[std_method]['time']:
                     print(f"      Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s) is faster than {std_method} time ({dataset_summary[std_method]['time']:.4f}s).")
                elif dataset_summary[best_gmw_time_method]['time'] > dataset_summary[std_method]['time']:
                     print(f"      {std_method} time ({dataset_summary[std_method]['time']:.4f}s) is faster than Fastest GMW time ({dataset_summary[best_gmw_time_method]['time']:.4f}s).")
                else:
                     print(f"      Fastest GMW and {std_method} had similar times ({dataset_summary[std_method]['time']:.4f}s).")
            else:
                print(f"    {std_method}: Results not available for this dataset.")


print("\nOverall Conclusion:")
print("The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.")
print("GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.")
print("Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.")
print("The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.")

--- Comprehensive Real-world Dataset Compression Benchmark Results (with ZSTD levels and more standard methods) ---

Benchmarking Results for Text Data:
  Original Size: 1089.25 KB
  gmw_zstd_1:
    Compressed Size: 474.16 KB
    Compression Time: 0.0472 seconds
    Compression Ratio: 2.30
  gmw_zstd_3:
    Compressed Size: 420.10 KB
    Compression Time: 0.0666 seconds
    Compression Ratio: 2.59
  gmw_zstd_6:
    Compressed Size: 396.23 KB
    Compression Time: 0.0630 seconds
    Compression Ratio: 2.75
  gmw_zstd_9:
    Compressed Size: 388.17 KB
    Compression Time: 0.1176 seconds
    Compression Ratio: 2.81
  standard_tar_gz:
    Compressed Size: 424.05 KB
    Compression Time: 0.1510 seconds
    Compression Ratio: 2.57
  standard_tar_bz2:
    Compressed Size: 321.20 KB
    Compression Time: 0.2329 seconds
    Compression Ratio: 3.39
  standard_tar_xz:
    Compressed Size: 355.74 KB
    Compression Time: 0.7969 seconds
    Compression Ratio: 3.06
  standard_zstd:
    Compressed Size: 419.73 KB
    Compression Time: 0.0121 seconds
    Compression Ratio: 2.60
  standard_brotli:
    Compressed Size: 353.02 KB
    Compression Time: 2.8939 seconds
    Compression Ratio: 3.09
  standard_lz4:
    Compressed Size: 697.54 KB
    Compression Time: 0.0066 seconds
    Compression Ratio: 1.56

Benchmarking Results for Image Data:
  Original Size: 181849.72 KB
  gmw_zstd_1:
    Compressed Size: 176809.16 KB
    Compression Time: 1.3124 seconds
    Compression Ratio: 1.03
  gmw_zstd_3:
    Compressed Size: 169995.34 KB
    Compression Time: 2.5405 seconds
    Compression Ratio: 1.07
  gmw_zstd_6:
    Compressed Size: 170220.54 KB
    Compression Time: 5.2250 seconds
    Compression Ratio: 1.07
  gmw_zstd_9:
    Compressed Size: 167410.13 KB
    Compression Time: 7.1867 seconds
    Compression Ratio: 1.09
  standard_tar_gz:
    Compressed Size: 165992.66 KB
    Compression Time: 11.4635 seconds
    Compression Ratio: 1.10
  standard_tar_bz2:
    Compressed Size: 143644.70 KB
    Compression Time: 23.5531 seconds
    Compression Ratio: 1.27
  standard_tar_xz:
    Compressed Size: 136373.63 KB
    Compression Time: 122.9488 seconds
    Compression Ratio: 1.33
  standard_zstd:
    Compressed Size: 169964.58 KB
    Compression Time: 3.3085 seconds
    Compression Ratio: 1.07
  standard_brotli:
    Compressed Size: 142198.13 KB
    Compression Time: 1143.7075 seconds
    Compression Ratio: 1.28
  standard_lz4:
    Compressed Size: 176870.91 KB
    Compression Time: 6.5068 seconds
    Compression Ratio: 1.03

Benchmarking Results for Audio Data:
  Original Size: 308897.86 KB
  gmw_zstd_1:
    Compressed Size: 235466.43 KB
    Compression Time: 13.1080 seconds
    Compression Ratio: 1.31
  gmw_zstd_3:
    Compressed Size: 226009.42 KB
    Compression Time: 8.8216 seconds
    Compression Ratio: 1.37
  gmw_zstd_6:
    Compressed Size: 221733.91 KB
    Compression Time: 12.9076 seconds
    Compression Ratio: 1.39
  gmw_zstd_9:
    Compressed Size: 219084.38 KB
    Compression Time: 17.9201 seconds
    Compression Ratio: 1.41
  standard_tar_gz:
    Compressed Size: 231722.18 KB
    Compression Time: 36.0358 seconds
    Compression Ratio: 1.33
  standard_tar_bz2:
    Compressed Size: 194090.88 KB
    Compression Time: 46.4658 seconds
    Compression Ratio: 1.59
  standard_tar_xz:
    Compressed Size: 192051.60 KB
    Compression Time: 236.6967 seconds
    Compression Ratio: 1.61
  standard_zstd:
    Compressed Size: 225549.34 KB
    Compression Time: 1253.3378 seconds
    Compression Ratio: 1.37
  standard_brotli:
    Compressed Size: 187766.91 KB
    Compression Time: 2826.0517 seconds
    Compression Ratio: 1.65
  standard_lz4:
    Compressed Size: 282752.89 KB
    Compression Time: 1229.2430 seconds
    Compression Ratio: 1.09

Benchmarking Results for Structured Data:
  Original Size: 3881.16 KB
  gmw_zstd_1:
    Compressed Size: 530.34 KB
    Compression Time: 0.0605 seconds
    Compression Ratio: 7.32
  gmw_zstd_3:
    Compressed Size: 533.33 KB
    Compression Time: 0.0355 seconds
    Compression Ratio: 7.28
  gmw_zstd_6:
    Compressed Size: 428.59 KB
    Compression Time: 0.0665 seconds
    Compression Ratio: 9.06
  gmw_zstd_9:
    Compressed Size: 386.63 KB
    Compression Time: 0.1039 seconds
    Compression Ratio: 10.04
  standard_tar_gz:
    Compressed Size: 400.04 KB
    Compression Time: 0.2556 seconds
    Compression Ratio: 9.70
  standard_tar_bz2:
    Compressed Size: 230.25 KB
    Compression Time: 0.8855 seconds
    Compression Ratio: 16.86
  standard_tar_xz:
    Compressed Size: 305.95 KB
    Compression Time: 1.6964 seconds
    Compression Ratio: 12.69
  standard_zstd:
    Compressed Size: 533.01 KB
    Compression Time: 0.0529 seconds
    Compression Ratio: 7.28
  standard_brotli:
    Compressed Size: 288.13 KB
    Compression Time: 12.4347 seconds
    Compression Ratio: 13.47
  standard_lz4:
    Compressed Size: 853.99 KB
    Compression Time: 0.0103 seconds
    Compression Ratio: 4.54

--- Overall Summary ---
Comparison of Compression Methods on Real-world Datasets:

Compression Ratio Summary:
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	gmw_zstd_9	standard_brotli	standard_lz4	standard_tar_bz2	standard_tar_gz	standard_tar_xz	standard_zstd
Text	2.30	2.59	2.75	2.81	3.09	1.56	3.39	2.57	3.06	2.60
Image	1.03	1.07	1.07	1.09	1.28	1.03	1.27	1.10	1.33	1.07
Audio	1.31	1.37	1.39	1.41	1.65	1.09	1.59	1.33	1.61	1.37
Structured	7.32	7.28	9.06	10.04	13.47	4.54	16.86	9.70	12.69	7.28

Compression Time Summary (seconds):
Data Type	gmw_zstd_1	gmw_zstd_3	gmw_zstd_6	gmw_zstd_9	standard_brotli	standard_lz4	standard_tar_bz2	standard_tar_gz	standard_tar_xz	standard_zstd
Text	0.0472	0.0666	0.0630	0.1176	2.8939	0.0066	0.2329	0.1510	0.7969	0.0121
Image	1.3124	2.5405	5.2250	7.1867	1143.7075	6.5068	23.5531	11.4635	122.9488	3.3085
Audio	13.1080	8.8216	12.9076	17.9201	2826.0517	1229.2430	46.4658	36.0358	236.6967	1253.3378
Structured	0.0605	0.0355	0.0665	0.1039	12.4347	0.0103	0.8855	0.2556	1.6964	0.0529

Key Observations:

- Text Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (2.59 vs 2.30).
    ZSTD Level 3 was slower than Level 1 (0.0666s vs 0.0472s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (2.75 vs 2.59).
    ZSTD Level 6 was faster than Level 3 (0.0630s vs 0.0666s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (2.81 vs 2.75).
    ZSTD Level 9 was slower than Level 6 (0.1176s vs 0.0630s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 2.81, Time 0.1176s
    Fastest GMW (gmw_zstd_1): Ratio 2.30, Time 0.0472s
    standard_brotli: Ratio 3.09, Time 2.8939s
      standard_brotli ratio (3.09) is better than Best GMW ratio (2.81).
      Fastest GMW time (0.0472s) is faster than standard_brotli time (2.8939s).
    standard_lz4: Ratio 1.56, Time 0.0066s
      Best GMW ratio (2.81) is better than standard_lz4 ratio (1.56).
      standard_lz4 time (0.0066s) is faster than Fastest GMW time (0.0472s).
    standard_tar_bz2: Ratio 3.39, Time 0.2329s
      standard_tar_bz2 ratio (3.39) is better than Best GMW ratio (2.81).
      Fastest GMW time (0.0472s) is faster than standard_tar_bz2 time (0.2329s).
    standard_tar_gz: Ratio 2.57, Time 0.1510s
      Best GMW ratio (2.81) is better than standard_tar_gz ratio (2.57).
      Fastest GMW time (0.0472s) is faster than standard_tar_gz time (0.1510s).
    standard_tar_xz: Ratio 3.06, Time 0.7969s
      standard_tar_xz ratio (3.06) is better than Best GMW ratio (2.81).
      Fastest GMW time (0.0472s) is faster than standard_tar_xz time (0.7969s).
    standard_zstd: Ratio 2.60, Time 0.0121s
      Best GMW ratio (2.81) is better than standard_zstd ratio (2.60).
      standard_zstd time (0.0121s) is faster than Fastest GMW time (0.0472s).

- Image Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.07 vs 1.03).
    ZSTD Level 3 was slower than Level 1 (2.5405s vs 1.3124s).
    ZSTD Level 6 achieved worse compression ratio than Level 3 (1.07 vs 1.07).
    ZSTD Level 6 was slower than Level 3 (5.2250s vs 2.5405s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (1.09 vs 1.07).
    ZSTD Level 9 was slower than Level 6 (7.1867s vs 5.2250s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 1.09, Time 7.1867s
    Fastest GMW (gmw_zstd_1): Ratio 1.03, Time 1.3124s
    standard_brotli: Ratio 1.28, Time 1143.7075s
      standard_brotli ratio (1.28) is better than Best GMW ratio (1.09).
      Fastest GMW time (1.3124s) is faster than standard_brotli time (1143.7075s).
    standard_lz4: Ratio 1.03, Time 6.5068s
      Best GMW ratio (1.09) is better than standard_lz4 ratio (1.03).
      Fastest GMW time (1.3124s) is faster than standard_lz4 time (6.5068s).
    standard_tar_bz2: Ratio 1.27, Time 23.5531s
      standard_tar_bz2 ratio (1.27) is better than Best GMW ratio (1.09).
      Fastest GMW time (1.3124s) is faster than standard_tar_bz2 time (23.5531s).
    standard_tar_gz: Ratio 1.10, Time 11.4635s
      standard_tar_gz ratio (1.10) is better than Best GMW ratio (1.09).
      Fastest GMW time (1.3124s) is faster than standard_tar_gz time (11.4635s).
    standard_tar_xz: Ratio 1.33, Time 122.9488s
      standard_tar_xz ratio (1.33) is better than Best GMW ratio (1.09).
      Fastest GMW time (1.3124s) is faster than standard_tar_xz time (122.9488s).
    standard_zstd: Ratio 1.07, Time 3.3085s
      Best GMW ratio (1.09) is better than standard_zstd ratio (1.07).
      Fastest GMW time (1.3124s) is faster than standard_zstd time (3.3085s).

- Audio Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved better compression ratio than Level 1 (1.37 vs 1.31).
    ZSTD Level 3 was faster than Level 1 (8.8216s vs 13.1080s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (1.39 vs 1.37).
    ZSTD Level 6 was slower than Level 3 (12.9076s vs 8.8216s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (1.41 vs 1.39).
    ZSTD Level 9 was slower than Level 6 (17.9201s vs 12.9076s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 1.41, Time 17.9201s
    Fastest GMW (gmw_zstd_3): Ratio 1.37, Time 8.8216s
    standard_brotli: Ratio 1.65, Time 2826.0517s
      standard_brotli ratio (1.65) is better than Best GMW ratio (1.41).
      Fastest GMW time (8.8216s) is faster than standard_brotli time (2826.0517s).
    standard_lz4: Ratio 1.09, Time 1229.2430s
      Best GMW ratio (1.41) is better than standard_lz4 ratio (1.09).
      Fastest GMW time (8.8216s) is faster than standard_lz4 time (1229.2430s).
    standard_tar_bz2: Ratio 1.59, Time 46.4658s
      standard_tar_bz2 ratio (1.59) is better than Best GMW ratio (1.41).
      Fastest GMW time (8.8216s) is faster than standard_tar_bz2 time (46.4658s).
    standard_tar_gz: Ratio 1.33, Time 36.0358s
      Best GMW ratio (1.41) is better than standard_tar_gz ratio (1.33).
      Fastest GMW time (8.8216s) is faster than standard_tar_gz time (36.0358s).
    standard_tar_xz: Ratio 1.61, Time 236.6967s
      standard_tar_xz ratio (1.61) is better than Best GMW ratio (1.41).
      Fastest GMW time (8.8216s) is faster than standard_tar_xz time (236.6967s).
    standard_zstd: Ratio 1.37, Time 1253.3378s
      Best GMW ratio (1.41) is better than standard_zstd ratio (1.37).
      Fastest GMW time (8.8216s) is faster than standard_zstd time (1253.3378s).

- Structured Data:
  GMW (ZSTD Levels) Comparison:
    ZSTD Level 3 achieved worse compression ratio than Level 1 (7.28 vs 7.32).
    ZSTD Level 3 was faster than Level 1 (0.0355s vs 0.0605s).
    ZSTD Level 6 achieved better compression ratio than Level 3 (9.06 vs 7.28).
    ZSTD Level 6 was slower than Level 3 (0.0665s vs 0.0355s).
    ZSTD Level 9 achieved better compression ratio than Level 6 (10.04 vs 9.06).
    ZSTD Level 9 was slower than Level 6 (0.1039s vs 0.0665s).
  GMW vs. Standard Methods Comparison:
    Best GMW Ratio (gmw_zstd_9): Ratio 10.04, Time 0.1039s
    Fastest GMW (gmw_zstd_3): Ratio 7.28, Time 0.0355s
    standard_brotli: Ratio 13.47, Time 12.4347s
      standard_brotli ratio (13.47) is better than Best GMW ratio (10.04).
      Fastest GMW time (0.0355s) is faster than standard_brotli time (12.4347s).
    standard_lz4: Ratio 4.54, Time 0.0103s
      Best GMW ratio (10.04) is better than standard_lz4 ratio (4.54).
      standard_lz4 time (0.0103s) is faster than Fastest GMW time (0.0355s).
    standard_tar_bz2: Ratio 16.86, Time 0.8855s
      standard_tar_bz2 ratio (16.86) is better than Best GMW ratio (10.04).
      Fastest GMW time (0.0355s) is faster than standard_tar_bz2 time (0.8855s).
    standard_tar_gz: Ratio 9.70, Time 0.2556s
      Best GMW ratio (10.04) is better than standard_tar_gz ratio (9.70).
      Fastest GMW time (0.0355s) is faster than standard_tar_gz time (0.2556s).
    standard_tar_xz: Ratio 12.69, Time 1.6964s
      standard_tar_xz ratio (12.69) is better than Best GMW ratio (10.04).
      Fastest GMW time (0.0355s) is faster than standard_tar_xz time (1.6964s).
    standard_zstd: Ratio 7.28, Time 0.0529s
      Best GMW ratio (10.04) is better than standard_zstd ratio (7.28).
      Fastest GMW time (0.0355s) is faster than standard_zstd time (0.0529s).

Overall Conclusion:
The GMW tool with different ZSTD levels and standard compression methods (tar.gz, tar.bz2, tar.xz) were benchmarked on real-world datasets.
GMW with higher ZSTD levels generally achieves better compression ratios, often competitive with or better than tar.gz, while remaining significantly faster than tar.gz, tar.bz2, and tar.xz.
Standard methods like tar.bz2 and tar.xz can achieve higher compression ratios than GMW, but with substantially longer compression times.
The optimal compression method depends on the specific requirements, balancing the need for smaller file sizes against the available time for compression.

Clean up
Subtask:
Remove the downloaded datasets and any temporary files or directories created during the process.

Reasoning: Remove the downloaded datasets directory and the temporary directory created for preparing datasets.


import shutil
import os

# Remove the directory containing downloaded datasets
if 'dataset_dir' in globals() and os.path.exists(dataset_dir):
    shutil.rmtree(dataset_dir)
    print(f"Removed downloaded datasets directory: {dataset_dir}")

# Remove the temporary directory for prepared datasets
if 'temp_dataset_dir' in globals() and os.path.exists(temp_dataset_dir):
    shutil.rmtree(temp_dataset_dir)
    print(f"Removed temporary directory for prepared datasets: {temp_dataset_dir}")

   Summary:
Data Analysis Key Findings
All required compression libraries (zstandard, brotli, and lz4) were successfully identified and installed.
Real-world datasets (Tiny Shakespeare, CIFAR-10 subset, Speech Commands subset, and UCI Adult Income) were downloaded, extracted, and prepared in a temporary directory.
The benchmarking process successfully measured the compressed size and time for each dataset using:
gmw_tool.py with ZSTD levels 1, 3, 6, and 9.
Standard methods: tar.gz, tar.bz2, tar.xz, pure Zstandard, Brotli, and pure LZ4.
Higher ZSTD levels with GMW generally achieved better compression ratios but took longer.
Standard methods like tar.bz2 and tar.xz often achieved better compression than tar.gz and pure LZ4, but with significantly longer compression times, especially for larger datasets.
Pure Zstandard and pure LZ4 generally offered faster compression times compared to tar-based methods.
Brotli showed strong compression ratios but had the longest compression times among the tested methods.
The GMW tool with higher ZSTD levels demonstrated competitive compression ratios compared to tar.gz while being significantly faster than tar.gz, tar.bz2, and tar.xz. 

    



print("Cleanup complete.")


